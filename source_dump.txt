# ==================================================
# Path: D:\killigraphy
# Detected tech: docker, javascript, python, react, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
killigraphy/
├── .git/
├── .venv/
├── killigchat/
│   ├── node_modules/
│   ├── public/
│   │   └── vite.svg
│   ├── src/
│   │   ├── assets/
│   │   │   └── react.svg
│   │   ├── App.css
│   │   ├── App.tsx
│   │   ├── index.css
│   │   ├── main.tsx
│   │   └── vite-env.d.ts
│   ├── .gitignore
│   ├── README.md
│   ├── eslint.config.js
│   ├── index.html
│   ├── package-lock.json
│   ├── package.json
│   ├── tsconfig.app.json
│   ├── tsconfig.json
│   ├── tsconfig.node.json
│   └── vite.config.ts
├── killigraphy/
│   ├── app/
│   │   └── _root/
│   ├── node_modules/
│   ├── public/
│   │   └── assets/
│   │       ├── icons/
│   │       │   ├── add-post.svg
│   │       │   ├── back.svg
│   │       │   ├── bookmark.svg
│   │       │   ├── chat.svg
│   │       │   ├── comment.png
│   │       │   ├── delete.svg
│   │       │   ├── edit.svg
│   │       │   ├── favicon.ico
│   │       │   ├── file-upload.svg
│   │       │   ├── filter.svg
│   │       │   ├── follow.svg
│   │       │   ├── gallery-add.svg
│   │       │   ├── google.svg
│   │       │   ├── home.svg
│   │       │   ├── like.svg
│   │       │   ├── liked.svg
│   │       │   ├── loader.svg
│   │       │   ├── logout.svg
│   │       │   ├── people.svg
│   │       │   ├── posts.svg
│   │       │   ├── profile-placeholder.svg
│   │       │   ├── save.svg
│   │       │   ├── saved.svg
│   │       │   ├── search.svg
│   │       │   ├── share.svg
│   │       │   └── wallpaper.svg
│   │       └── images/
│   │           ├── lo_go_remove_bg.png
│   │           ├── logo.png
│   │           ├── logo.svg
│   │           ├── logo_round.png
│   │           ├── profile.png
│   │           ├── side-img.svg
│   │           └── sidebar.jpg
│   ├── src/
│   │   ├── _auth/
│   │   │   ├── forms/
│   │   │   │   ├── SigninForm.tsx
│   │   │   │   └── SignupForm.tsx
│   │   │   └── AuthLayout.tsx
│   │   ├── _root/
│   │   │   ├── pages/
│   │   │   │   ├── AllUsers.tsx
│   │   │   │   ├── CreatePost.tsx
│   │   │   │   ├── EditPost.tsx
│   │   │   │   ├── Explore.tsx
│   │   │   │   ├── Home.tsx
│   │   │   │   ├── LikedPosts.tsx
│   │   │   │   ├── PostDetails.tsx
│   │   │   │   ├── Profile.tsx
│   │   │   │   ├── ProfileConnections.tsx
│   │   │   │   ├── Saved.tsx
│   │   │   │   ├── UpdateProfile.tsx
│   │   │   │   └── index.ts
│   │   │   └── RootLayout.tsx
│   │   ├── components/
│   │   │   ├── forms/
│   │   │   │   └── PostForm.tsx
│   │   │   ├── shared/
│   │   │   │   ├── Bottombar.tsx
│   │   │   │   ├── ChangePasswordDialog.tsx
│   │   │   │   ├── ChatBottomSheet.tsx
│   │   │   │   ├── CommentInput.tsx
│   │   │   │   ├── FileUpLoader.tsx
│   │   │   │   ├── FollowingSidebar.tsx
│   │   │   │   ├── GridPostList.tsx
│   │   │   │   ├── LeftSidebar.tsx
│   │   │   │   ├── Loader.tsx
│   │   │   │   ├── PostCard.tsx
│   │   │   │   ├── PostComments.tsx
│   │   │   │   ├── PostCommentsPreview.tsx
│   │   │   │   ├── PostStats.tsx
│   │   │   │   ├── ProfileUploader.tsx
│   │   │   │   ├── Topbar.tsx
│   │   │   │   ├── UserCard.tsx
│   │   │   │   ├── UserCardHorizontal.tsx
│   │   │   │   ├── UserList.tsx
│   │   │   │   └── VoiceCallDialog.tsx
│   │   │   └── ui/
│   │   │       ├── badge.tsx
│   │   │       ├── button.tsx
│   │   │       ├── dialog.tsx
│   │   │       ├── form.tsx
│   │   │       ├── input.tsx
│   │   │       ├── label.tsx
│   │   │       ├── textarea.tsx
│   │   │       ├── toast.tsx
│   │   │       └── toaster.tsx
│   │   ├── constants/
│   │   │   └── index.ts
│   │   ├── context/
│   │   │   └── AuthContext.tsx
│   │   ├── hooks/
│   │   │   ├── use-toast.ts
│   │   │   ├── useChatSocket.ts
│   │   │   ├── useDebounce.ts
│   │   │   └── useVoiceCall.ts
│   │   ├── lib/
│   │   ├── types/
│   │   │   ├── index.ts
│   │   │   └── shared.ts
│   │   ├── App.tsx
│   │   ├── globals.css
│   │   ├── main.tsx
│   │   └── vite-env.d.ts
│   ├── .env.local
│   ├── .gitignore
│   ├── Dockerfile
│   ├── README.md
│   ├── components.json
│   ├── eslint.config.js
│   ├── index.html
│   ├── nginx.conf
│   ├── package-lock.json
│   ├── package.json
│   ├── postcss.config.cjs
│   ├── tailwind.config.cjs
│   ├── tsconfig.app.json
│   ├── tsconfig.json
│   ├── tsconfig.node.json
│   └── vite.config.ts
├── killigraphy_back_end/
│   ├── node_modules/
│   ├── src/
│   │   ├── config/
│   │   │   ├── imagekit.ts
│   │   │   └── redis.ts
│   │   ├── controllers/
│   │   │   ├── auth.controller.ts
│   │   │   ├── comment.controller.ts
│   │   │   ├── post.controller.ts
│   │   │   ├── save.controller.ts
│   │   │   └── user.controller.ts
│   │   ├── cron/
│   │   │   └── refreshSuggestions.ts
│   │   ├── enum/
│   │   │   ├── chat.ts
│   │   │   ├── chatHistory.ts
│   │   │   └── message.ts
│   │   ├── factories/
│   │   │   ├── CommentFactory/
│   │   │   │   ├── CommentFactory.ts
│   │   │   │   └── ICommentFactory.ts
│   │   │   ├── PostFactory/
│   │   │   │   ├── IPostFactory.ts
│   │   │   │   └── PostFactory.ts
│   │   │   ├── SaveFactory/
│   │   │   │   ├── ISaveFactory.ts
│   │   │   │   └── SaveFactory.ts
│   │   │   └── UserFactory/
│   │   │       ├── IUserFactory.ts
│   │   │       └── UserFactory.ts
│   │   ├── middleware/
│   │   │   ├── autoMarkSeen.ts
│   │   │   ├── requireAuth.ts
│   │   │   └── upload.ts
│   │   ├── models/
│   │   │   ├── Chat.ts
│   │   │   ├── ChatHistory.ts
│   │   │   ├── Comment.ts
│   │   │   ├── Message.ts
│   │   │   ├── Posts.ts
│   │   │   ├── Saves.ts
│   │   │   └── Users.ts
│   │   ├── repositories/
│   │   │   ├── comment.repository.ts
│   │   │   ├── post.repository.ts
│   │   │   ├── save.repository.ts
│   │   │   └── user.repository.ts
│   │   ├── routes/
│   │   │   ├── auth.ts
│   │   │   ├── chats.ts
│   │   │   ├── comments.ts
│   │   │   ├── messages.ts
│   │   │   ├── posts.ts
│   │   │   ├── saves.ts
│   │   │   └── users.ts
│   │   ├── services/
│   │   │   ├── auth.service.ts
│   │   │   ├── comment.service.ts
│   │   │   ├── feed.service.ts
│   │   │   ├── post.service.ts
│   │   │   ├── save.service.ts
│   │   │   └── user.service.ts
│   │   ├── strategies/
│   │   │   ├── FeedStrategy/
│   │   │   │   ├── FeedContext.ts
│   │   │   │   ├── IFeedStrategy.ts
│   │   │   │   └── PersonalizedFeedStrategy.ts
│   │   │   └── UpdateStrategy/
│   │   │       ├── IUpdateStrategy.ts
│   │   │       ├── PostUpdateStrategy.ts
│   │   │       └── UserUpdateStrategy.ts
│   │   ├── types/
│   │   │   └── index.ts
│   │   ├── utils/
│   │   │   ├── adapters/
│   │   │   │   ├── ImageKitAdapter/
│   │   │   │   │   ├── IImageKitAdapter.ts
│   │   │   │   │   └── ImageKitAdapter.ts
│   │   │   │   └── RedisAdapter/
│   │   │   │       ├── IRedisAdapter.ts
│   │   │   │       └── RedisAdapter.ts
│   │   │   ├── singleton/
│   │   │   │   ├── ImageKitAdapterSingleton.ts
│   │   │   │   └── RedisAdapterSingleton.ts
│   │   │   ├── default-user.py
│   │   │   ├── default_posts.py
│   │   │   ├── hashPassword.ts
│   │   │   └── sendEmail.ts
│   │   ├── .env
│   │   ├── app.ts
│   │   └── socket.ts
│   ├── uploads/
│   │   └── users/
│   │       └── f43961b29de93bf7c7d90f5dd1108b3e
│   ├── .gitignore
│   ├── Dockerfile
│   ├── package-lock.json
│   ├── package.json
│   └── tsconfig.json
├── .gitignore
├── SECURITY.md
├── default_posts.json
├── default_users.json
└── docker-compose.yml
```

## FILE CONTENTS

### killigchat\eslint.config.js
```js
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

```

### killigchat\vite.config.ts
```ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

### killigchat\src\App.tsx
```tsx
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import './App.css'

function App() {
  const [count, setCount] = useState(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + React</h1>
      <div className="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
        <p>
          Edit <code>src/App.tsx</code> and save to test HMR
        </p>
      </div>
      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
}

export default App

```

### killigchat\src\main.tsx
```tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

```

### killigchat\src\vite-env.d.ts
```ts
/// <reference types="vite/client" />

```

### killigraphy\eslint.config.js
```js
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

```

### killigraphy\postcss.config.cjs
```cjs
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

```

### killigraphy\tailwind.config.cjs
```cjs
/** @type {import('tailwindcss').Config} */
const defaultTheme = require('tailwindcss/defaultTheme')

module.exports = {
  darkMode: ['class'],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px',
      
      },
    },
    extend: {
      colors: {
        'primary-500': '#877EFF',
        'primary-600': '#5D5FEF',
        'secondary-500': '#FFB620',
        'off-white': '#D0DFFF',
        'red': '#FF5A5A',
        'dark-1': '#000000',
        'dark-2': '#09090A',
        'dark-3': '#101012',
        'dark-4': '#1F1F22',
        'light-1': '#FFFFFF',
        'light-2': '#EFEFEF',
        'light-3': '#7878A3',
        'light-4': '#5C5C7B',
      },
      screens: {
        'xs': '480px',
      
      },
      width: {
        '420': '420px',
        '465': '465px',
      },
      fontFamily: {
        inter: ['Inter', 'sans-serif'],

      },
      keyframes: {
        'accordion-down': {
          from: { height: 0 },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: 0 },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
};
```

### killigraphy\vite.config.ts
```ts
import path from 'path';
import react from '@vitejs/plugin-react';
import { defineConfig } from 'vite';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 80,
    host: true,
    watch: {
      usePolling: true, // Use polling to detect file changes
      interval: 100, // Polling interval in milliseconds
    },
    proxy: {
      '/api': {
        target: 'http://localhost:8085', // Backend server URL
        changeOrigin: true,
        secure: false, // If your backend uses HTTPS, set this to true
        rewrite: (path) => path.replace(/^\/api/, ''), // Remove /api prefix when forwarding
      },
    }
  },
});
```

### killigraphy\src\App.tsx
```tsx
import { Routes, Route, Navigate } from 'react-router-dom';

import AuthLayout from './_auth/AuthLayout';
import SigninForm from './_auth/forms/SigninForm';
import SignupForm from './_auth/forms/SignupForm';

import {
    AllUsers,
    CreatePost,
    EditPost,
    Explore,
    Home,
    LikedPosts,
    PostDetails,
    Profile,
    Saved,
    UpdateProfile
} from './_root/pages';

import './globals.css';
import RootLayout from './_root/RootLayout';
import { Toaster } from './components/ui/toaster';
import { useUserContext } from './context/AuthContext';
import Loader from "@/components/shared/Loader";
import ProfileConnections from './_root/pages/ProfileConnections';

const App = () => {
    const { isAuthenticated, isLoading } = useUserContext();

    if (isLoading) return (
        <div className="w-full h-full flex-center">
            <Loader />
        </div >
    );
    return (
        <main className="flex h-screen">
            <Routes>
                {/* Redirect root to sign-in */}
                <Route
                    path="/"
                    element={
                        isAuthenticated ? (
                            <Navigate to="/home" replace />
                        ) : (
                            <Navigate to="/sign-in" replace />
                        )
                    }
                />

                {/* Public routes */}
                <Route element={<AuthLayout />}>
                    <Route path="/sign-in" element={<SigninForm />} />
                    <Route path="/sign-up" element={<SignupForm />} />
                </Route>

                {/* Private routes */}
                <Route element={<RootLayout />}>
                    <Route path="/home" element={<Home />} />
                    <Route path="/explore" element={<Explore />} />
                    <Route path="/saved" element={<Saved />} />
                    <Route path="/all-users" element={<AllUsers />} />
                    <Route path="/create-post" element={<CreatePost />} />
                    <Route path="/update-post/:postId" element={<EditPost />} />
                    <Route path="/posts/:postId" element={<PostDetails />} />
                    <Route path="/profile/:userId/*" element={<Profile />} />
                    <Route path="/update-profile/:userId" element={<UpdateProfile />} />
                    <Route path="/liked-posts" element={<LikedPosts />} />
                    <Route path="/profile/:userId/connections" element={<ProfileConnections />} />
                </Route>
            </Routes>

            <Toaster />
        </main>
    );
};

export default App;

```

### killigraphy\src\main.tsx
```tsx
import ReactDOM from 'react-dom/client';
import App from './App';
import { BrowserRouter } from 'react-router-dom';
import AuthProvider from './context/AuthContext';
import { QueryProvider } from './lib/react-query/QueryProvider';

ReactDOM.createRoot(document.getElementById('root')!).render(
    <BrowserRouter>
        <QueryProvider>
            <AuthProvider>
                <App />
            </AuthProvider>
        </QueryProvider>
    </BrowserRouter>,
);
```

### killigraphy\src\vite-env.d.ts
```ts
/// <reference types="vite/client" />
```

### killigraphy\src\components\forms\PostForm.tsx
```tsx
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"
import { z } from "zod"
import { Button } from "@/components/ui/button"
import {
    Form,
    FormControl,
    FormField,
    FormItem,
    FormLabel,
    FormMessage,
} from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Textarea } from "../ui/textarea"
import FileUpLoader from "../shared/FileUpLoader"
import { PostValidation } from "@/lib/validation"
import { useCreatePostMutation, useUpdatePostMutation } from "@/lib/react-query/QueriesAndMutations"
import { useToast } from "@/hooks/use-toast"
import { useNavigate } from "react-router-dom"
import { Post } from "@/lib/api"

type PostFormProps = {
    post?: Post;
    action: "Create" | "Update";
    prefillCaption?: string;
    prefillFile?: File;
}

const PostForm = ({ post, action, prefillCaption, prefillFile }: PostFormProps) => {
    const { mutateAsync: createPost, isPending: isLoadingCreate } = useCreatePostMutation();
    const { mutateAsync: updatePost, isPending: isLoadingUpdate } = useUpdatePostMutation();

    const { toast } = useToast();
    const navigate = useNavigate();

    const form = useForm<z.infer<typeof PostValidation>>({
        resolver: zodResolver(PostValidation),
        defaultValues: {
            caption: post ? post.caption : prefillCaption || "",
            file: post?.imageURL
                ? [new File([""], post.imageURL)]
                : prefillFile
                    ? [prefillFile]
                    : [],
            location: post ? post.location : "",
            tags: post ? post.tags.join(',') : "",
        },
    })

    // 2. Define a submit handler.
    async function onSubmit(values: z.infer<typeof PostValidation>) {
        if (post && action === "Update") {
            const isImageChanged = values.file[0] instanceof File;

            const updatedPost = await updatePost(
                {
                    postId: post._id,
                    post: {
                        caption: values.caption,
                        location: values.location,
                        tags: values.tags,
                        image: isImageChanged ? (values.file[0] as File) : undefined,
                    },
                }
            );

            if (!updatedPost) throw new Error("Update failed");
            toast({ title: "Post updated successfully" });
            return navigate(`/posts/${post._id}`);
        }

        const newPost = await createPost({
            ...values,
            image: values.file[0],
        });

        if (!newPost) {
            toast({
                title: "Error creating post",
                description: "There was an error creating your post. Please try again.",
                variant: "destructive",
            })
            return;
        }
        navigate("/home")
    }

    return (
        <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="flex flex-col gap-9 w-full max-w-5xl">
                <FormField
                    control={form.control}
                    name="caption"
                    render={({ field }) => (
                        <FormItem>
                            <FormLabel className="shad-form_label">Caption</FormLabel>
                            <FormControl>
                                <Textarea className="shad-textarea custom-scrollbar" {...field} />
                            </FormControl>
                            <FormMessage className="shad-form_message" />
                        </FormItem>
                    )}
                />

                <FormField
                    control={form.control}
                    name="file"
                    render={({ field }) => (
                        <FormItem>
                            <FormLabel className="shad-form_label">Add Photos</FormLabel>
                            <FormControl>
                                <FileUpLoader
                                    fieldChange={field.onChange}
                                    mediaUrl={
                                        post?.imageURL ? post.imageURL : prefillFile ? URL.createObjectURL(prefillFile) : undefined
                                    }
                                />
                            </FormControl>
                            <FormMessage className="shad-form_message" />
                        </FormItem>
                    )}
                />

                <FormField
                    control={form.control}
                    name="location"
                    render={({ field }) => (
                        <FormItem>
                            <FormLabel className="shad-form_label">Add Location</FormLabel>
                            <FormControl>
                                <Input type="text" className="shad-input" {...field} />
                            </FormControl>
                            <FormMessage className="shad-form_message" />
                        </FormItem>
                    )}
                />

                <FormField
                    control={form.control}
                    name="tags"
                    render={({ field }) => (
                        <FormItem>
                            <FormLabel className="shad-form_label">Add Tags (separated by comma ", ")</FormLabel>
                            <FormControl>
                                <Input type="text" className="shad-input" placeholder="Art, Expression, Learning, etc." {...field} />
                            </FormControl>
                            <FormMessage className="shad-form_message" />
                        </FormItem>
                    )}
                />

                <div className="flex gap-4 items-center justify-end">
                    <Button type="button" className="shad-button_dark_4 h-10 w-28" onClick={() => navigate('/')}>
                        Cancel
                    </Button>
                    <Button type="submit" className="shad-button_primary whitespace-nowrap h-12 w-28"
                        disabled={isLoadingCreate || isLoadingUpdate}
                    >
                        {isLoadingCreate || isLoadingUpdate ? "Loading..." : action === "Create" ? "Create Post" : "Update Post"}
                    </Button>
                </div>
            </form>
        </Form>
    )
}

export default PostForm
```

### killigraphy\src\components\shared\Bottombar.tsx
```tsx
import { Link, useLocation } from "react-router-dom";

import { bottombarLinks } from "@/constants";

const Bottombar = () => {
    const { pathname } = useLocation();

    return (
        <section className="bottom-bar">
            {bottombarLinks.map((link) => {
                const isActive = pathname === link.route;
                return (
                    <Link
                        key={`bottombar-${link.label}`}
                        to={link.route}
                        className={`${isActive && "rounded-[10px] bg-primary-500 "
                            } flex-center flex-col gap-1 p-2 transition`}>
                        <img
                            src={link.imgURL}
                            alt={link.label}
                            width={16}
                            height={16}
                            className={`${isActive && "invert-white"}`}
                        />

                        <p className="tiny-medium text-light-2">{link.label}</p>
                    </Link>
                );
            })}
        </section>
    );
};

export default Bottombar;
```

### killigraphy\src\components\shared\ChangePasswordDialog.tsx
```tsx
import {
    Dialog,
    DialogContent,
    DialogDescription,
    DialogFooter,
    DialogHeader,
    DialogTitle,
    DialogTrigger,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import {
    Form,
    FormField,
    FormItem,
    FormLabel,
    FormControl,
    FormMessage,
} from "@/components/ui/form";
import {
    useChangePasswordMutation,
    useRequestOtpMutation,
    useVerifyOtpMutation,
} from "@/lib/react-query/QueriesAndMutations";
import { useUserContext } from "@/context/AuthContext";
import { useToast } from "@/hooks/use-toast";
import { useEffect, useState } from "react";

const changePasswordSchema = z
    .object({
        email: z.string().email(),
        otp: z.string().length(6, "OTP must be 6 digits"),
        oldPassword: z.string().min(6, "Old password is required"),
        newPassword: z.string().min(6, "New password must be at least 6 characters"),
        confirmPassword: z.string(),
    })
    .refine((data) => data.newPassword === data.confirmPassword, {
        message: "Passwords do not match",
        path: ["confirmPassword"],
    });

type ChangePasswordValues = z.infer<typeof changePasswordSchema>;

const ChangePasswordDialog = () => {
    const { user } = useUserContext();
    const { toast } = useToast();
    const { mutateAsync: changePassword, isPending } = useChangePasswordMutation();
    const { mutateAsync: requestOtp, isPending: isSendingOtp } = useRequestOtpMutation();
    const { mutateAsync: verifyOtp, isPending: isVerifyingOtp } = useVerifyOtpMutation();

    const [isOtpSent, setIsOtpSent] = useState(false);
    const [isOtpVerified, setIsOtpVerified] = useState(false);
    const [countdown, setCountdown] = useState(0);

    const form = useForm<ChangePasswordValues>({
        resolver: zodResolver(changePasswordSchema),
        defaultValues: {
            email: user.email,
            otp: "",
            oldPassword: "",
            newPassword: "",
            confirmPassword: "",
        },
    });

    const handleSendOtp = async () => {
        try {
            await requestOtp({ email: user.email });
            toast({ title: "OTP sent. Check your email" });
            setIsOtpSent(true);
            setCountdown(60);
        } catch (err: any) {
            toast({
                title: "Failed to send OTP",
                description: err?.response?.data?.message || "Please try again",
                variant: "destructive",
            });
        }
    };

    useEffect(() => {
        if (countdown > 0) {
            const timer = setTimeout(() => setCountdown(countdown - 1), 1000);
            return () => clearTimeout(timer);
        }
    }, [countdown]);

    const handleVerifyOtp = async () => {
        const { email, otp } = form.getValues();
        try {
            const res = await verifyOtp({ email, otp }) as { verified: boolean };
            if (res.verified) {
                toast({ title: "OTP verified" });
                setIsOtpVerified(true);
            } else {
                toast({ title: "Incorrect OTP", variant: "destructive" });
            }
        } catch (err: any) {
            toast({
                title: "Verification failed",
                description: err?.response?.data?.message || "Invalid OTP",
                variant: "destructive",
            });
        }
    };

    const onSubmit = async (values: ChangePasswordValues) => {
        try {
            await changePassword({
                userId: user._id,
                oldPassword: values.oldPassword,
                newPassword: values.newPassword,
            });
            toast({ title: "Password updated successfully" });
            form.reset();
        } catch (error: any) {
            toast({
                title: "Failed to update password",
                description: error?.response?.data?.message || "Something went wrong.",
                variant: "destructive",
            });
        }
    };

    return (
        <Dialog>
            <DialogTrigger asChild>
                <Button variant="outline" size="sm" className="ml-2">
                    Change Password
                </Button>
            </DialogTrigger>
            <DialogContent className="sm:max-w-md">
                <DialogHeader>
                    <DialogTitle>Change Password</DialogTitle>
                    <DialogDescription>
                        Verify OTP then update your password.
                    </DialogDescription>
                </DialogHeader>
                <Form {...form}>
                    <form onSubmit={form.handleSubmit(onSubmit)} className="grid gap-4 py-4">
                        {/* Email + Send OTP */}
                        <div className="flex items-end gap-2">
                            <FormField
                                control={form.control}
                                name="email"
                                render={({ field }) => (
                                    <FormItem className="flex-1">
                                        <FormLabel>Email</FormLabel>
                                        <FormControl>
                                            <Input {...field} disabled />
                                        </FormControl>
                                    </FormItem>
                                )}
                            />
                            <div className="pt-[1.625rem]">
                                <Button
                                    type="button"
                                    variant="secondary"
                                    className={`${isSendingOtp ? "shad-button_primary" : "shad-button_primary_ghost"}`}
                                    onClick={handleSendOtp}
                                    disabled={isSendingOtp || countdown > 0}
                                >
                                    {isSendingOtp ? "Sending..." : countdown > 0 ? `Resend (${countdown})` : "Send OTP"}
                                </Button>
                            </div>
                        </div>

                        {/* OTP + Verify */}
                        {isOtpSent && (
                            <div className="flex items-center gap-2">
                                <FormField
                                    control={form.control}
                                    name="otp"
                                    render={({ field }) => (
                                        <FormItem className="flex-1">
                                            <FormLabel>OTP</FormLabel>
                                            <FormControl>
                                                <Input {...field} maxLength={6} disabled={isOtpVerified} />
                                            </FormControl>
                                        </FormItem>
                                    )}
                                />
                                < div className="pt-[1.625rem]">
                                    <Button
                                        type="button"
                                        variant="secondary"
                                        className={`${isVerifyingOtp ? "shad-button_primary" : "shad-button_primary_ghost"}`}
                                        onClick={handleVerifyOtp}
                                        disabled={isVerifyingOtp || isOtpVerified}
                                    >
                                        {isVerifyingOtp ? "Verifying..." : "Verify"}
                                    </Button>
                                </div>
                            </div>
                        )}

                        {/* Password Fields (only show when verified) */}
                        {isOtpVerified && (
                            <>
                                <FormField
                                    control={form.control}
                                    name="oldPassword"
                                    render={({ field }) => (
                                        <FormItem>
                                            <FormLabel>Old Password</FormLabel>
                                            <FormControl>
                                                <Input type="password" {...field} />
                                            </FormControl>
                                            <FormMessage />
                                        </FormItem>
                                    )}
                                />
                                <FormField
                                    control={form.control}
                                    name="newPassword"
                                    render={({ field }) => (
                                        <FormItem>
                                            <FormLabel>New Password</FormLabel>
                                            <FormControl>
                                                <Input type="password" {...field} />
                                            </FormControl>
                                            <FormMessage />
                                        </FormItem>
                                    )}
                                />
                                <FormField
                                    control={form.control}
                                    name="confirmPassword"
                                    render={({ field }) => (
                                        <FormItem>
                                            <FormLabel>Confirm Password</FormLabel>
                                            <FormControl>
                                                <Input type="password" {...field} />
                                            </FormControl>
                                            <FormMessage />
                                        </FormItem>
                                    )}
                                />
                            </>
                        )}

                        <DialogFooter>
                            <Button type="submit" disabled={!isOtpVerified || isPending}>
                                {isPending ? "Updating..." : "Save changes"}
                            </Button>
                        </DialogFooter>
                    </form>
                </Form>
            </DialogContent>
        </Dialog >
    );
};

export default ChangePasswordDialog;

```

### killigraphy\src\components\shared\ChatBottomSheet.tsx
```tsx
// src/components/chat/ChatBottomSheet.tsx
import {
    Dialog,
    DialogContent,
    DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { X, Phone, ImageIcon, Mic } from "lucide-react";
import { useEffect, useState } from "react";
import { MessageType, User } from "@/lib/api";
import { useSendMessageMutation } from "@/lib/react-query/QueriesAndMutations";
import socket from "@/lib/socket";

const ChatBottomSheet = ({ user, onClose }: { user: User & { chatId: string }; onClose: () => void }) => {
    const [open, setOpen] = useState(false);
    const [message, setMessage] = useState("");
    const [messages, setMessages] = useState<any[]>([]);
    const { mutate: sendMessage } = useSendMessageMutation();

    useEffect(() => {
        const handleNewMessage = (msg: any) => {
            if (msg.chat === user.chatId) {
                setMessages((prev) => [...prev, msg]);
            }
        };

        socket.on("new_message", handleNewMessage);
        return () => {
            socket.off("new_message", handleNewMessage);
        };
    }, [user.chatId]);

    const handleSendMessage = () => {
        if (!message.trim()) return;

        sendMessage(
            {
                chatId: user.chatId,
                content: message,
                type: MessageType.TEXT,
            },
            {
                onSuccess: (newMessage) => {
                    socket.emit("send_message", {
                        chatId: user.chatId,
                        message: newMessage,
                    });
                    setMessages((prev) => [...prev, newMessage]);
                    setMessage("");
                },
            }
        );
    };

    return (
        <Dialog open={open} onOpenChange={(val) => {
            setOpen(val);
            if (!val) onClose();
        }}>
            <DialogTrigger asChild>
                <Button size="sm" className="text-xs" onClick={() => setOpen(true)}>
                    Chat
                </Button>
            </DialogTrigger>

            <DialogContent className="sm:max-w-full bottom-0 fixed inset-x-0 !mt-0 !translate-y-0 !h-[80vh] rounded-t-2xl p-0">
                {/* Header */}
                <div className="flex items-center justify-between p-4 border-b">
                    <div className="flex items-center gap-3">
                        <img
                            src={user.imageUrl}
                            alt={user.name}
                            className="w-10 h-10 rounded-full object-cover"
                        />
                        <div>
                            <p className="text-sm font-semibold">{user.name}</p>
                            <p className="text-xs text-muted-foreground">@{user.username}</p>
                        </div>
                    </div>
                    <div className="flex gap-2">
                        <Button size="icon" variant="ghost">
                            <Phone className="w-5 h-5" />
                        </Button>
                        <Button size="icon" variant="ghost" onClick={() => setOpen(false)}>
                            <X className="w-5 h-5" />
                        </Button>
                    </div>
                </div>

                {/* Chat messages */}
                <div className="flex-1 overflow-y-auto p-4 space-y-2 text-sm">
                    {messages.map((msg, i) => (
                        <div
                            key={i}
                            className={`max-w-[75%] px-3 py-2 rounded-lg ${msg.sender === user._id
                                ? "bg-muted text-black"
                                : "bg-primary text-white ml-auto"
                                }`}
                        >
                            {msg.content}
                        </div>
                    ))}
                </div>

                {/* Input section */}
                <div className="border-t p-4 flex items-center gap-2">
                    <Input
                        placeholder="Aa..."
                        value={message}
                        onChange={(e) => setMessage(e.target.value)}
                        className="flex-1"
                        onKeyDown={(e) => e.key === "Enter" && handleSendMessage()}
                    />
                    <Button size="icon" variant="ghost">
                        <Mic className="w-5 h-5" />
                    </Button>
                    <Button size="icon" variant="ghost">
                        <ImageIcon className="w-5 h-5" />
                    </Button>
                    <Button onClick={handleSendMessage}>Send</Button>
                </div>
            </DialogContent>
        </Dialog>
    );
};

export default ChatBottomSheet;

```

### killigraphy\src\components\shared\CommentInput.tsx
```tsx
import { useEffect, useState } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";

import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
    Form,
    FormControl,
    FormField,
    FormItem,
    FormMessage,
} from "@/components/ui/form";

import { useCreateCommentMutation } from "@/lib/react-query/QueriesAndMutations";
import { useToast } from "@/hooks/use-toast";

const commentSchema = z.object({
    content: z.string().min(1, "Không được để trống"),
});

interface Props {
    postId: string;
    parentId?: string;
    defaultValue?: string;
    inputRef?: React.RefObject<HTMLInputElement>;
}

const CommentInput = ({ postId, parentId, defaultValue = "", inputRef }: Props) => {
    const { toast } = useToast();
    const [isSubmitting, setIsSubmitting] = useState(false);

    const createCommentMutation = useCreateCommentMutation();

    const form = useForm<z.infer<typeof commentSchema>>({
        resolver: zodResolver(commentSchema),
        defaultValues: {
            content: defaultValue,
        },
    });

    useEffect(() => {
        if (defaultValue) {
            form.setValue("content", defaultValue);
        }
    }, [defaultValue]);

    const handleSubmit = async (values: z.infer<typeof commentSchema>) => {
        setIsSubmitting(true);
        try {
            await createCommentMutation.mutateAsync({
                content: values.content,
                postId,
                parentId,
            });
            form.reset();
        } catch (err: any) {
            toast({
                title: "Lỗi bình luận",
                description:
                    err?.response?.data?.message || "Gửi bình luận thất bại, thử lại.",
                variant: "destructive",
            });
        } finally {
            setIsSubmitting(false);
        }
    };

    return (
        <Form {...form}>
            <form onSubmit={form.handleSubmit(handleSubmit)} className="flex gap-2 mt-2">
                <FormField
                    control={form.control}
                    name="content"
                    render={({ field }) => (
                        <FormItem className="flex-1">
                            <FormControl>
                                <Input
                                    {...field}
                                    ref={(el) => {
                                        field.ref(el);
                                        if (inputRef && el) inputRef.current = el;
                                    }}
                                    placeholder="Viết bình luận..."
                                    className="text-sm"
                                />
                            </FormControl>
                            <FormMessage />
                        </FormItem>
                    )}
                />

                <Button type="submit" className="shad-button_primary" size="sm" disabled={isSubmitting}>
                    Gửi
                </Button>
            </form>
        </Form>
    );
};

export default CommentInput;

```

### killigraphy\src\components\shared\FileUpLoader.tsx
```tsx
import { useCallback, useState } from 'react' // Importing React and useCallback from React
import { FileWithPath, useDropzone } from 'react-dropzone' // Importing useDropzone from react-dropzone
import { Button } from '../ui/button'
// React-dropzone is a library for creating file upload components with drag-and-drop functionality.

type FileUploaderProps = {
    fieldChange: (files: File[]) => void;
    mediaUrl?: string;
}

const FileUpLoader = ({ fieldChange, mediaUrl }: FileUploaderProps) => {
    const [, setFile] = useState<File[]>([])
    const [fileUrl, setFileUrl] = useState(mediaUrl || ''); // State to store the URL of the uploaded file.
    // useState is a React hook that allows you to add state to functional components.

    // useDropzone is a hook that provides the functionality for drag-and-drop file uploads.
    // It takes an object with options and a callback function to handle file drops.
    const onDrop = useCallback((acceptedFiles: FileWithPath[]) => {
        setFile(acceptedFiles) // Sets the accepted files to the state.
        fieldChange(acceptedFiles) // Calls the fieldChange function with the accepted files.
        setFileUrl(URL.createObjectURL(acceptedFiles[0])) // Creates a URL for the first accepted file and sets it to the state.
    }, [fieldChange]) // useCallback memoizes the function to prevent unnecessary re-renders.
    // The dependency array [file] ensures that the function is recreated only when the file state changes.

    const { getRootProps, // This function returns the props needed to create the dropzone area.
        getInputProps,  // This function returns the props needed for the input element that handles file selection.
    } = useDropzone({
        onDrop,
        accept: {
            'image/*': ['.png', '.jpg', '.jpeg', '.svg'], // Accepts image files with the specified extensions.
        },
    })

    const displayUrl = fileUrl || mediaUrl;

    return (
        <div {...getRootProps()} className="flex flex-center flex-col bg-dark-3 rounded-xl cursor-pointer">
            <input {...getInputProps()}
                className='cursor-pointer'
            /> {
                displayUrl ? (
                    <>
                        <div className="flex flex-1 justify-center w-full p-5 lg:p-10">
                            <div className="relative max-h-[600px] overflow-auto rounded-xl">
                                <img
                                    src={displayUrl}
                                    alt="uploaded-file"
                                    className="w-auto h-auto max-h-[600px] object-contain"
                                />
                            </div>
                        </div>
                        <p className="file_uploader-label">
                            Click or drag photos to replace the image
                        </p>
                    </>
                ) : (
                    <div className='file_uploader-box'>
                        <img
                            src='/assets/icons/file-upload.svg'
                            alt='file-upload'
                            className="w-24 h-24"
                        />

                        <h3 className="base-medium text-light-2 mb-2 mt-6">
                            Drag & Drop your photos here
                        </h3>
                        <p className="text-light-4 small-regular mb-6">
                            SVG, PNG, JPG
                        </p>

                        <Button className='shad-button_dark_4'>
                            Select from device
                        </Button>
                    </div>
                )
            }
        </div>
    )
}

export default FileUpLoader
```

### killigraphy\src\components\shared\FollowingSidebar.tsx
```tsx
import { Button } from '@/components/ui/button';
import { useFollowersQueryMutation, useGetPrivateChatMutation } from '@/lib/react-query/QueriesAndMutations';
import { useUserContext } from '@/context/AuthContext';
import Loader from './Loader';
import { User } from '@/lib/api';
import ChatBottomSheet from './ChatBottomSheet';
import { useState } from 'react';

const FollowingSidebar = () => {
    const { user } = useUserContext();
    const { data, isPending: isLoading } = useFollowersQueryMutation(user._id);
    const [selectedUser, setSelectedUser] = useState<User | null>(null);
    const [chatId, setChatId] = useState<string | null>(null);
    const { mutate: getChat } = useGetPrivateChatMutation();

    const handleOpenChat = (targetUser: User) => {
        getChat(
            targetUser._id,
            {
                onSuccess: (data) => {
                    const chat = data as { _id: string };
                    setSelectedUser(targetUser);
                    setChatId(chat._id);
                },
            }
        );
    };

    const followers = Array.isArray(data) ? data : [];

    return (
        <div className="space-y-4">
            <h3 className="text-lg font-semibold">Following</h3>

            {isLoading && (
                <div className="flex-center">
                    <Loader />
                </div>
            )}

            {followers.length === 0 ? (
                <p className="text-sm text-muted-foreground">You are not following anyone yet.</p>
            ) : (
                followers.map((user) => (
                    <div key={user._id} className="flex items-center justify-between gap-3">
                        <div className="flex items-center gap-3">
                            <img
                                src={user.imageUrl}
                                alt={user.name}
                                className="w-10 h-10 rounded-full object-cover"
                            />
                            <div>
                                <p className="text-sm font-medium">{user.name}</p>
                                <p className="text-xs text-muted-foreground">@{user.username}</p>
                            </div>
                        </div>
                        <Button onClick={() => handleOpenChat(user)}>Chat</Button>
                    </div>
                ))
            )}

            {selectedUser && chatId && (
                <ChatBottomSheet
                    user={{ ...selectedUser, chatId }}
                    onClose={() => {
                        setSelectedUser(null);
                        setChatId(null);
                    }}
                />
            )}
        </div>
    );
};

export default FollowingSidebar;

```

### killigraphy\src\components\shared\GridPostList.tsx
```tsx
import { Link } from "react-router-dom";
import { useUserContext } from "@/context/AuthContext";
import PostStats from "./PostStats";
import { Post } from "@/lib/api";
import { useNavigate } from "react-router-dom";

type GridPostListProps = {
    posts: Post[];
    showUser?: boolean;
    showStats?: boolean;
    showCreatePostCard?: boolean;
};

const GridPostList = ({
    posts,
    showUser = true,
    showStats = true,
    showCreatePostCard = false
}: GridPostListProps) => {
    const { user } = useUserContext();
    const navigate = useNavigate();

    return (
        <ul className="grid-container">
            {showCreatePostCard && (
                <li
                    className="relative min-w-80 h-80 border-2 border-dashed border-primary-500 flex-center hover:bg-dark-4 transition cursor-pointer"
                    onClick={() => navigate("/create-post")}
                >
                    <div className="text-center">
                        <img
                            src="/assets/icons/add-post.svg"
                            alt="create"
                            className="w-8 h-8 mx-auto mb-2"
                        />
                        <p className="text-primary-500 font-semibold">Create New Post</p>
                    </div>
                </li>
            )}

            {posts.length === 0 && !showCreatePostCard && (
                <li className="col-span-full text-center text-light-3">
                    No posts available.
                </li>
            )}

            {posts.map((post) => (
                <li key={post._id} className="relative min-w-80 h-80">
                    <Link to={`/posts/${post._id}`} className="grid-post_link">
                        <img
                            src={post.imageURL}
                            alt="post"
                            className="h-full w-full object-cover"
                        />
                    </Link>

                    <div className="grid-post_user">
                        {showUser && (
                            <div className="flex items-center justify-start gap-2 flex-1">
                                <img
                                    src={
                                        post.creator.imageUrl?.startsWith("https://ik.imagekit.io/killigraphy/avatars/avatar")
                                            ? "/assets/icons/profile-placeholder.svg"
                                            : post.creator.imageUrl || "/assets/icons/profile-placeholder.svg"
                                    }
                                    alt="creator"
                                    className="w-8 h-8 rounded-full"
                                />
                                <p className="line-clamp-1">{post.creator.name}</p>
                            </div>
                        )}
                        {showStats && <PostStats post={post} userId={user._id} />}
                    </div>
                </li>
            ))}
        </ul>
    );
};

export default GridPostList;
```

### killigraphy\src\components\shared\LeftSidebar.tsx
```tsx
import { Link, NavLink, useLocation, useNavigate } from 'react-router-dom'
import { Button } from '../ui/button'
import { INITIAL_USER, useUserContext } from '@/context/AuthContext'
import { useSignOutAccountMutation } from '@/lib/react-query/QueriesAndMutations'
import { sidebarLinks } from '@/constants'
import { INavLink } from '@/types'

const LeftSideBar = () => {
    const { pathname } = useLocation()
    const navigate = useNavigate()
    const { user, setUser, setIsAuthenticated } = useUserContext();
    const { mutate: signOut } = useSignOutAccountMutation()

    const handleSignOut = async (
        e: React.MouseEvent<HTMLButtonElement, MouseEvent>
    ) => {
        e.preventDefault();
        signOut();
        setIsAuthenticated(false);
        setUser(INITIAL_USER);
        navigate("/sign-in");
    };

    return (
        <nav className="flex flex-col justify-between h-screen p-4 w-60 lg:w-72">
            <div className='flex flex-col gap-11'>
                <Link to='/' className='flex gap-3 justify-center items-center'>
                    <img
                        src='/assets/images/logo_round.png'
                        alt='logo'
                        className='w-20 h-20 lg:w-24 lg:h-24 rounded-full'
                    />
                </Link>

                <Link to={`/profile/${user._id}`} className='flex gap-3 items-center'>
                    <img
                        src={user.imageUrl || 'https://ik.imagekit.io/killigraphy/profile-placeholder.svg'}
                        alt='profile'
                        className='h-14 w-14 rounded-full'
                    />
                    <div className='flex flex-col'>
                        <p className='body-bold truncate max-w-[150px]'>
                            {user.name}
                        </p>

                        <p className='small-regular text-light-3 truncate max-w-[150px]'>
                            @{user.username}
                        </p>
                    </div>
                </Link>

                <ul className='flex flex-col gap-6'>
                    {sidebarLinks.map((link: INavLink) => {
                        const isActive = pathname === link.route

                        return (
                            <li
                                key={link.label}
                                className={`leftsidebar-link group ${isActive ? 'bg-primary-500' : ''}`}
                            >
                                <NavLink to={link.route} className='flex gap-4 items-center p-4'>
                                    <img
                                        src={link.imgURL}
                                        alt={link.label}
                                        className={`group-hover:invert-white ${isActive ? 'invert-white' : ''}`}
                                    />
                                    {link.label}
                                </NavLink>
                            </li>
                        )
                    })}
                </ul>
            </div>
            <Button variant='ghost' className='shad-button_ghost' onClick={handleSignOut}>
                <img src='/assets/icons/logout.svg' alt='logout' />
                <p className='small-medium lg:base-medium'>Logout</p>
            </Button>
        </nav>
    )
}

export default LeftSideBar
```

### killigraphy\src\components\shared\Loader.tsx
```tsx
const loader = () => {
    return (
        <div className="flex-center w-full" >
            <img src="/assets/icons/loader.svg" alt="Loading..." width={24} height={24} />
        </div>
    )
}

export default loader
```

### killigraphy\src\components\shared\PostCard.tsx
```tsx
import { useUserContext } from '@/context/AuthContext'
import { multiFormatDateString } from '@/lib/utils'
import { Link } from 'react-router-dom'
import PostStats from './PostStats'
import { Post } from '@/lib/api'
import PostCommentsPreview from './PostCommentsPreview'
import CommentInput from './CommentInput'
import { useGetCommentsByPostMutation } from '@/lib/react-query/QueriesAndMutations'

type PostCardProps = {
    post: Post
}

const PostCard = ({ post }: PostCardProps) => {
    const { user } = useUserContext()
    const { data: comments = [] } = useGetCommentsByPostMutation(post._id);

    return (
        <div className='post-card'>
            <div className='flex-between'>
                <div className='flex items-center gap-3'>
                    <Link to={`/profile/${post?.creator?._id}`}>
                        <img
                            src={
                                post.creator.imageUrl?.startsWith("https://ik.imagekit.io/killigraphy/avatars/avatar")
                                    ? "/assets/icons/profile-placeholder.svg"
                                    : post.creator.imageUrl || "/assets/icons/profile-placeholder.svg"
                            }
                            alt="Creator Image"
                            className='w-10 h-10 rounded-full lg:h-12'
                        />
                    </Link>

                    <div className='flex flex-col'>
                        <p className='base-medium lg:body-bold text-light-1'>{post?.creator?.name || 'Anonymous'}</p>

                        <div className='flex-center gap-2 text-light-3'>
                            <p className='subtle-semibold lg:small-regular'>{multiFormatDateString(post?.createdAt)}</p>
                            -
                            <p className='subtle-semibold lg:small-regular'>{post?.location}</p>
                        </div>
                    </div>
                </div>
                <Link to={`/update-post/${post._id}`}
                    className={`${user?._id !== post?.creator._id && 'hidden'}`}
                >
                    <img
                        src='/assets/icons/edit.svg'
                        alt="Edit Icon"
                        className='w-8 h-8 lg:w-8 lg:h-8'
                    />
                </Link>
            </div>

            <Link to={`/posts/${post._id}`} className='flex flex-col gap-3'>
                <div className='small-medium lg:base-medium py-5'>
                    <p style={{ whiteSpace: 'pre-line' }}>{post?.caption}</p>
                    <ul className='flex gap-1 mt-2'>
                        {post?.tags?.map((tag: string) => (
                            <li key={tag} className='text-light-3'>
                                #{tag}
                            </li>
                        ))}
                    </ul>
                </div>
                <img
                    src={post?.imageURL || '/assets/icons/profile-placeholder.svg'}
                    alt="Post Image"
                    className='post-card_img'
                />
            </Link>

            <PostStats post={post} userId={user?._id} />
            <PostCommentsPreview postId={post._id} />

            {comments.length <= 1 && (
                <CommentInput postId={post._id} />
            )}
        </div>
    )
}

export default PostCard
```

### killigraphy\src\components\shared\PostComments.tsx
```tsx
import { useRef, useState } from "react";
import { useUserContext } from "@/context/AuthContext";
import {
    useDeleteCommentMutation,
    useGetCommentsByPostMutation,
} from "@/lib/react-query/QueriesAndMutations";
import { PopulatedComment } from "@/types/shared";
import { multiFormatDateString } from "@/lib/utils";
import Loader from "./Loader";
import { Trash2 } from "lucide-react";
import CommentInput from "./CommentInput";

interface PostCommentsProps {
    postId: string;
    postCreatorId: string;
}

const PostComments = ({ postId, postCreatorId }: PostCommentsProps) => {
    const { user } = useUserContext();
    const [replyTo, setReplyTo] = useState<{ id: string; name: string } | null>(null);
    const inputRef = useRef<HTMLInputElement | null>(null);

    const { data: comments = [], isPending } = useGetCommentsByPostMutation(postId);
    const deleteCommentMutation = useDeleteCommentMutation(postId);

    const handleDelete = (commentId: string) => {
        deleteCommentMutation.mutate(commentId);
    };

    const renderReplies = (parentId: string) =>
        comments
            .filter((c) => c.parent === parentId)
            .map((reply) => (
                <div key={reply._id} className="ml-6 mt-2 border-l border-muted pl-3">
                    <CommentItem comment={reply} />
                </div>
            ));

    const highlightMention = (text: string) => {
        const match = text.match(/^@(\w+)\s/);
        if (!match) return text;
        return (
            <>
                <span className="text-primary font-semibold">@{match[1]}</span>
                {text.replace(`@${match[1]}`, "")}
            </>
        );
    };

    const CommentItem = ({ comment }: { comment: PopulatedComment }) => (
        <div className="flex flex-col gap-1 mt-3">
            <div className="flex items-start gap-2">
                <img
                    src={
                        comment.user.imageUrl?.startsWith("https://ik.imagekit.io/killigraphy/avatars/avatar")
                            ? "/assets/icons/profile-placeholder.svg"
                            : comment.user.imageUrl || "/assets/icons/profile-placeholder.svg"
                    }
                    alt="avatar"
                    className="w-8 h-8 rounded-full"
                />
                <div className="flex-1">
                    <div className="flex items-center gap-2">
                        <p className="text-light-1 font-semibold">{comment.user.name}</p>
                        <span className="text-xs text-light-3">
                            {multiFormatDateString(comment.createdAt as string)}
                        </span>
                    </div>
                    <p className="text-light-1 text-sm">{highlightMention(comment.content)}</p>
                    <div className="text-sm flex items-center gap-3 mt-1">
                        <button
                            onClick={() => {
                                setReplyTo({ id: comment._id, name: comment.user.name });
                                setTimeout(() => inputRef.current?.focus(), 100);
                            }}
                            className="text-primary-500 hover:underline"
                        >
                            Reply
                        </button>
                        {user?._id === postCreatorId && (
                            <Trash2
                                size={16}
                                onClick={() => handleDelete(comment._id)}
                                className="cursor-pointer text-red-500"
                            />
                        )}
                    </div>
                </div>
            </div>
            {renderReplies(comment._id)}
        </div>
    );

    const rootComments = comments.filter((c) => !c.parent);

    return (
        <div className="mt-6">
            <h4 className="text-light-1 font-semibold mb-2">Comments</h4>
            {isPending ? (
                <Loader />
            ) : (
                <div className="mt-2">
                    {rootComments.length === 0 && (
                        <p className="text-muted-foreground">No comments yet.</p>
                    )}
                    {rootComments.map((comment) => (
                        <CommentItem key={comment._id} comment={comment} />
                    ))}
                </div>
            )}

            <div className="mt-4">
                <CommentInput
                    postId={postId}
                    parentId={replyTo?.id}
                    defaultValue={replyTo ? `@${replyTo.name} ` : ""}
                    inputRef={inputRef as React.RefObject<HTMLInputElement>}
                />
            </div>
        </div>
    );
};

export default PostComments;

```

### killigraphy\src\components\shared\PostCommentsPreview.tsx
```tsx
import { useState } from "react";
import { useGetCommentsByPostMutation, useGetPostByIdMutation } from "@/lib/react-query/QueriesAndMutations";
import { multiFormatDateString } from "@/lib/utils";
import { Button } from "../ui/button";
import PostComments from "./PostComments";

const PostCommentsPreview = ({ postId }: { postId: string }) => {
    const [showAll, setShowAll] = useState(false);
    const { data: comments = [], isPending } = useGetCommentsByPostMutation(postId);
    const { data: post } = useGetPostByIdMutation(postId)

    const latest = comments
        .filter((c) => !c.parent)
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())[0];

    if (isPending) return null;

    if (showAll && post) {
        return <PostComments postId={postId} postCreatorId={post.creator._id} />
    }

    return (
        <div className="mt-4">
            {latest ? (
                <div className="flex gap-2 items-start">
                    <img
                        src={
                            latest.user.imageUrl?.startsWith("https://ik.imagekit.io/killigraphy/avatars/avatar")
                                ? "/assets/icons/profile-placeholder.svg"
                                : latest.user.imageUrl || "/assets/icons/profile-placeholder.svg"
                        }
                        alt="avatar"
                        className="w-8 h-8 rounded-full"
                    />
                    <div>
                        <p className="text-sm text-light-1 font-medium">{latest.user.name}</p>
                        <p className="text-light-2 text-sm">{latest.content}</p>
                        <span className="text-xs text-muted-foreground">
                            {multiFormatDateString(latest.createdAt as string)}
                        </span>
                    </div>
                </div>
            ) : (
                <p className="flex flex-center text-muted-foreground text-sm">Chưa có bình luận</p>
            )}

            {comments.length > 1 && (
                <Button
                    variant="link"
                    onClick={() => setShowAll(true)}
                    className="mt-2 p-0 text-primary-500 text-sm"
                >
                    Xem tất cả {comments.length} bình luận
                </Button>
            )}
        </div>
    );
};

export default PostCommentsPreview;
```

### killigraphy\src\components\shared\PostStats.tsx
```tsx
import { useState, useEffect } from "react";
import { useLocation, useNavigate } from "react-router-dom";
import { checkIsLiked } from "@/lib/utils";
import {
    useToggleLikePostMutation,
    useSavePostMutation,
    useUnsavePostMutation,
    useGetSavedPostsMutation,
    useGetCommentsByPostMutation,
} from "@/lib/react-query/QueriesAndMutations";
import { Post } from "@/lib/api";

type PostStatsProps = {
    post: Post
    userId: string;
};

const PostStats = ({ post, userId }: PostStatsProps) => {
    const location = useLocation();
    const navigate = useNavigate();

    const [likes, setLikes] = useState<string[]>(post.likes || []);
    const [isSaved, setIsSaved] = useState(false);

    const { mutate: toggleLike } = useToggleLikePostMutation();
    const { mutate: savePost } = useSavePostMutation();
    const { mutate: unsavePost } = useUnsavePostMutation();
    const { data: savedPosts } = useGetSavedPostsMutation();

    const { data: comments = [] } = useGetCommentsByPostMutation(post._id);

    useEffect(() => {
        const saved = savedPosts?.some((p) => p._id === post._id);
        setIsSaved(!!saved);
    }, [savedPosts, post._id]);

    const handleLikePost = (
        e: React.MouseEvent<HTMLImageElement, MouseEvent>
    ) => {
        e.stopPropagation();

        let likesArray = [...likes];

        if (likesArray.includes(userId)) {
            likesArray = likesArray.filter((Id) => Id !== userId);
        } else {
            likesArray.push(userId);
        }

        setLikes(likesArray);
        toggleLike(post._id);
    };

    const handleSavePost = (
        e: React.MouseEvent<HTMLImageElement, MouseEvent>
    ) => {
        e.stopPropagation();

        if (isSaved) {
            setIsSaved(false);
            unsavePost(post._id);
        } else {
            setIsSaved(true);
            savePost(post._id);
        }
    };

    const containerStyles = location.pathname.startsWith("/profile")
        ? "w-full"
        : "";

    return (
        <div
            className={`flex justify-between items-center z-20 ${containerStyles}`}>
            <div className="flex gap-4 items-center mr-5">
                <div className="flex gap-2 items-center">
                    <img
                        src={`${checkIsLiked(likes, userId)
                            ? "/assets/icons/liked.svg"
                            : "/assets/icons/like.svg"
                            }`}
                        alt="like"
                        width={20}
                        height={20}
                        onClick={(e) => handleLikePost(e)}
                        className="cursor-pointer"
                    />
                    <p className="small-medium lg:base-medium">{likes.length}</p>
                </div>

                <div className="flex gap-2 items-center">
                    <img
                        src="/assets/icons/chat.svg"
                        alt="comment"
                        width={20}
                        height={20}
                        onClick={() => navigate(`/posts/${post._id}`)}
                        className="cursor-pointer"
                    />
                    <p className="small-medium lg:base-medium">{comments.length}</p>
                </div>
            </div>

            <div className="flex gap-2">
                <img
                    src={isSaved ? "/assets/icons/saved.svg" : "/assets/icons/save.svg"}
                    alt="share"
                    width={20}
                    height={20}
                    className="cursor-pointer"
                    onClick={(e) => handleSavePost(e)}
                />
            </div>
        </div>
    );
};

export default PostStats;
```

### killigraphy\src\components\shared\ProfileUploader.tsx
```tsx
import { useCallback, useState } from "react";
import { FileWithPath, useDropzone } from "react-dropzone";
import { Dialog, DialogContent, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { convertFileToUrl } from "@/lib/utils";
import Cropper, { Area } from "react-easy-crop";
import getCroppedImg from "@/lib/getCroppedImage";

type ProfileUploaderProps = {
    fieldChange: (files: File[]) => void;
    mediaUrl: string;
    onAvatarConfirmed?: (file: File) => void;
};

const ProfileUploader = ({ fieldChange, mediaUrl, onAvatarConfirmed }: ProfileUploaderProps) => {
    const [fileUrl, setFileUrl] = useState<string>(mediaUrl);
    const [previewUrl, setPreviewUrl] = useState<string>('');
    const [showDialog, setShowDialog] = useState<boolean>(false);
    const [selectedFile, setSelectedFile] = useState<File | null>(null); // File to be cropped

    const [crop, setCrop] = useState({ x: 0, y: 0 }); // Crop position in pixels at the top left corner
    const [zoom, setZoom] = useState(1); // Zoom level
    const [croppedAreaPixels, setCroppedAreaPixels] = useState<Area>() // Area to crop in pixels 

    const onDrop = useCallback((acceptedFiles: FileWithPath[]) => {
        const newFile = acceptedFiles[0]; // Get the first file from the accepted files
        if (newFile) {
            setSelectedFile(newFile); // Set the selected file for cropping
            setPreviewUrl(convertFileToUrl(newFile)); // Convert the file to a URL for preview
            setShowDialog(true); // Show the dialog for cropping
        }
    }, []);

    const onCropComplete = (_: any, croppedAreaPixels: Area) => {
        setCroppedAreaPixels(croppedAreaPixels);
    };

    const confirmSelection = async () => {
        if (!selectedFile || !croppedAreaPixels) return; // Ensure a file is selected and cropped area is defined

        const croppedBlob = await getCroppedImg(previewUrl, croppedAreaPixels); // Get the cropped image as a blob
        const croppedFile = new File([croppedBlob], selectedFile.name, { type: selectedFile.type }); // Create a new file from the cropped blob 

        onAvatarConfirmed?.(croppedFile);
        fieldChange([croppedFile]); // Call the fieldChange function with the cropped file
        setFileUrl(URL.createObjectURL(croppedBlob)); // Create a URL for the cropped blob
        setShowDialog(false); // Close the dialog
    };

    const cancelSelection = () => {
        setSelectedFile(null); // Reset the selected file
        setPreviewUrl("");  // Clear the preview URL
        setShowDialog(false); // Close the dialog
    };

    const { getRootProps, getInputProps } = useDropzone({
        onDrop,
        accept: { "image/*": [".png", ".jpeg", ".jpg"] },
    });

    return (
        <>
            <div {...getRootProps()} className="cursor-pointer flex-center gap-4">
                <input {...getInputProps()} className="cursor-pointer" />
                <img
                    src={fileUrl || "/assets/icons/profile-placeholder.svg"}
                    alt="profile"
                    className="h-24 w-24 rounded-full object-cover object-top"
                />
                <p className="text-primary-500 small-regular md:base-semibold">
                    Change profile photo
                </p>
            </div>

            <Dialog open={showDialog} onOpenChange={setShowDialog}>
                <DialogContent className="sm:max-w-md">
                    <DialogHeader>
                        <DialogTitle>Preview your new avatar</DialogTitle>
                    </DialogHeader>

                    {/* Cropper */}
                    <div className="relative w-full h-64 bg-black">
                        <Cropper
                            image={previewUrl}
                            crop={crop}
                            zoom={zoom}
                            aspect={1}
                            cropShape="round"
                            showGrid={false}
                            onCropChange={setCrop}
                            onZoomChange={setZoom}
                            onCropComplete={onCropComplete}
                        />
                    </div>

                    <DialogFooter className="mt-4">
                        <Button variant="outline" onClick={cancelSelection}>
                            Cancel
                        </Button>
                        <Button onClick={confirmSelection}>Confirm</Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>
        </>
    );
};

export default ProfileUploader;

```

### killigraphy\src\components\shared\Topbar.tsx
```tsx
import { Link, useNavigate } from 'react-router-dom'
import { Button } from '../ui/button'
import { INITIAL_USER, useUserContext } from '@/context/AuthContext'
import { useSignOutAccountMutation } from '@/lib/react-query/QueriesAndMutations'

const Topbar = () => {
    const navigate = useNavigate()
    const { user, setUser, setIsAuthenticated } = useUserContext();
    const { mutate: signOut } = useSignOutAccountMutation()

    const handleSignOut = async (
        e: React.MouseEvent<HTMLButtonElement, MouseEvent>
    ) => {
        e.preventDefault();
        signOut();
        setIsAuthenticated(false);
        setUser(INITIAL_USER);
        navigate("/sign-in");
    };

    return (
        <section className='topbar'>
            <div className='flex-between py-4 px-5'>
                <Link to='/' className='flex gap-3 items-center'>
                    <img
                        src='/assets/images/logo_round.png'
                        alt='logo'
                        className='w-16 h-16'
                    />
                </Link>

                <div className='flex gap-4'>
                    <Button variant='ghost' className='shad-button_ghost' onClick={handleSignOut}>
                        <img src='/assets/icons/logout.svg' alt='logout' />
                    </Button>

                    <Link to={`/profile/${user._id}`} className='flex-center gap-3'>
                        <img
                            src={user.imageUrl || '/assets/images/profile-placeholder.svg'}
                            alt='profile'
                            className='h-8 w-8 rounded-full'
                        />
                        <span className='text-sm font-semibold truncate max-w-[75px]'>{user.name}</span>
                    </Link>
                </div>
            </div>
        </section>
    )
}

export default Topbar

```

### killigraphy\src\components\shared\UserCard.tsx
```tsx
import { Link } from "react-router-dom";

import { Button } from "../ui/button";
import { User } from "@/lib/api";
import { useUserContext } from "@/context/AuthContext";
import { useIsFollowingQueryMutation, useToggleFollowMutation } from "@/lib/react-query/QueriesAndMutations";

type UserCardProps = {
    user: User
};

const UserCard = ({ user }: UserCardProps) => {
    const { user: currentUser } = useUserContext()
    const { data: followStatus, isLoading: isChecking } = useIsFollowingQueryMutation(user._id, user._id !== currentUser._id);
    const { mutateAsync: toggleFollow, isPending: isToggling } = useToggleFollowMutation();

    const handleFollow = async (e: React.MouseEvent) => {
        e.preventDefault();
        await toggleFollow(user._id);
    };

    const isSelf = currentUser._id === user._id;
    const isFollowing = followStatus?.isFollowing;

    return (
        <Link to={`/profile/${user._id}`} className="user-card">
            <img
                src={
                    user.imageUrl?.startsWith("https://ik.imagekit.io/killigraphy/avatars/avatar")
                        ? "/assets/icons/profile-placeholder.svg"
                        : user.imageUrl || "/assets/icons/profile-placeholder.svg"
                }
                alt="creator"
                className="rounded-full w-14 h-14"
            />

            <div className="flex-center flex-col gap-1">
                <p className="base-medium text-light-1 text-center line-clamp-1">
                    {user.name}
                </p>
                <p className="small-regular text-light-3 text-center line-clamp-1">
                    @{user.username}
                </p>
            </div>

            {!isSelf && (
                <Button
                    type="button"
                    size="sm"
                    className={`px-5 ${isFollowing ? ".shad-button_dark_4_primary" : "shad-button_primary"}`}
                    onClick={handleFollow}
                    disabled={isToggling || isChecking}
                >
                    {isToggling || isChecking ? "..." : isFollowing ? "Unfollow" : "Follow"}
                </Button>
            )}
        </Link>
    );
};

export default UserCard;
```

### killigraphy\src\components\shared\UserCardHorizontal.tsx
```tsx
import { Link } from "react-router-dom";
import { Button } from "../ui/button";
import { User } from "@/lib/api";
import { useUserContext } from "@/context/AuthContext";

type Props = {
    user: User;
    isFollowing: boolean;
    onToggleFollow: () => void;
};

const UserCardHorizontal = ({ user, isFollowing, onToggleFollow }: Props) => {
    const { user: currentUser } = useUserContext();
    const isSelf = currentUser._id === user._id;

    return (
        <div className="flex items-center justify-between gap-3 px-3 py-2 bg-dark-3 rounded-md">
            <Link
                to={`/profile/${user._id}`}
                className="flex items-center gap-3 flex-1"
            >
                <img
                    src={
                        user.imageUrl?.startsWith("https://ik.imagekit.io/killigraphy/avatars/avatar")
                            ? "/assets/icons/profile-placeholder.svg"
                            : user.imageUrl || "/assets/icons/profile-placeholder.svg"
                    }
                    alt={user.name}
                    className="w-10 h-10 rounded-full object-cover"
                />
                <div>
                    <p className="text-sm font-semibold">{user.name}</p>
                    <p className="text-xs text-light-3">@{user.username}</p>
                </div>
            </Link>

            {!isSelf && (
                <Button
                    size="sm"
                    className={`text-xs ${isFollowing ? "shad-button_dark_4_primary" : "shad-button_primary"
                        }`}
                    onClick={onToggleFollow}
                >
                    {isFollowing ? "Unfollow" : "Follow"}
                </Button>
            )}
        </div>
    );
};

export default UserCardHorizontal;

```

### killigraphy\src\components\shared\UserList.tsx
```tsx
import Loader from "./Loader";
import UserCard from "./UserCard";
import UserCardHorizontal from "./UserCardHorizontal";
import {
    useFollowersQueryMutation,
    useFollowingQuery,
} from "@/lib/react-query/QueriesAndMutations";
import { User } from "@/lib/api";
import { useEffect, useRef, useCallback } from "react";

type FollowState = {
    initial: boolean;
    current: boolean;
};

type Props = {
    userId: string;
    type: "followers" | "following" | "suggestions";
    layout?: "horizontal" | "vertical" | "grid";
    overrideUsers?: User[];
    localFollowMap: Record<string, FollowState>;
    onInitFollowState: (users: User[]) => void;
    onToggleFollow: (userId: string) => void;
    enableInfiniteScroll?: boolean;
    onLoadMore?: () => void;
    hasMore?: boolean;
    isLoadingMore?: boolean;
};

const UserList = ({
    userId,
    type,
    layout = "vertical",
    localFollowMap,
    onInitFollowState,
    onToggleFollow,
    overrideUsers,
    enableInfiniteScroll = false,
    onLoadMore,
    hasMore,
    isLoadingMore,
}: Props) => {
    const followersQuery = useFollowersQueryMutation(userId);
    const followingQuery = useFollowingQuery(userId);

    const data = overrideUsers ?? (
        type === "followers"
            ? followersQuery.data
            : type === "following"
                ? followingQuery.data
                : []
    );

    const isLoading = overrideUsers
        ? false
        : type === "followers"
            ? followersQuery.isLoading
            : type === "following"
                ? followingQuery.isLoading
                : false;

    const usersToShow = overrideUsers ?? data ?? [];

    useEffect(() => {
        if (data && onInitFollowState) {
            onInitFollowState(data);
        }
    }, [data]);

    const observer = useRef<IntersectionObserver | null>(null);
    const lastElementRef = useCallback(
        (node: HTMLDivElement | null) => {
            if (!enableInfiniteScroll || !hasMore || isLoadingMore) return;

            if (observer.current) observer.current.disconnect();

            observer.current = new IntersectionObserver((entries) => {
                if (entries[0].isIntersecting && onLoadMore) {
                    onLoadMore();
                }
            });

            if (node) observer.current.observe(node);
        },
        [enableInfiniteScroll, hasMore, isLoadingMore]
    );

    if (isLoading) return <Loader />;

    return (
        <div className="w-full mt-4">
            {type !== "suggestions" && (
                <h2 className="h3-bold mb-4">
                    {type === "followers" ? "Followers" : "Following"}
                </h2>
            )}

            {usersToShow.length === 0 ? (
                <p className="text-light-4">No {type} found.</p>
            ) : (
                <ul
                    className={
                        layout === "grid"
                            ? "grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4"
                            : "flex flex-col gap-3"
                    }
                >
                    {usersToShow.map((u, idx) => {
                        const isLast = idx === usersToShow.length - 1;

                        const card = layout === "horizontal" ? (
                            <UserCardHorizontal
                                key={u._id}
                                user={u}
                                isFollowing={localFollowMap[u._id]?.current ?? false}
                                onToggleFollow={() => onToggleFollow(u._id)}
                            />
                        ) : (
                            <UserCard key={u._id} user={u} />
                        );

                        return (
                            <div
                                key={u._id}
                                ref={enableInfiniteScroll && isLast ? lastElementRef : null}
                            >
                                {card}
                            </div>
                        );
                    })}
                </ul>
            )}

            {isLoadingMore && (
                <div className="mt-4">
                    <Loader />
                </div>
            )}
        </div>
    );
};

export default UserList;

```

### killigraphy\src\components\shared\VoiceCallDialog.tsx
```tsx
// src/components/chat/VoiceCallDialog.tsx
import { Dialog, DialogContent } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { useEffect, useState } from "react";
import { Phone, X } from "lucide-react";
import socket from "@/lib/socket";
import { User } from "@/lib/api";
import { useVoiceCall } from "@/hooks/useVoiceCall";

type Props = {
    currentUser: User;
};

const VoiceCallDialog = ({ }: Props) => {
    const [incomingCall, setIncomingCall] = useState<{
        from: User;
        offer: RTCSessionDescriptionInit;
    } | null>(null);
    const [inCall, setInCall] = useState(false);

    const {
        answerCall,
        handleAnswer,
        handleRemoteCandidate,
        endCall,
        localStream,
    } = useVoiceCall();

    // === Lắng nghe sự kiện gọi đến ===
    useEffect(() => {
        socket.on("incoming_call", ({ from, offer }: { from: User; offer: RTCSessionDescriptionInit }) => {
            setIncomingCall({ from, offer });
        });

        socket.on("call_answered", ({ answer }: { answer: RTCSessionDescriptionInit }) => {
            handleAnswer(answer);
        });

        socket.on("ice_candidate", ({ candidate }: { candidate: RTCIceCandidateInit }) => {
            handleRemoteCandidate(candidate);
        });

        socket.on("call_ended", () => {
            setIncomingCall(null);
            setInCall(false);
            // Stop media stream nếu cần
            localStream.current?.getTracks().forEach((track) => track.stop());
        });

        return () => {
            socket.off("incoming_call");
            socket.off("call_answered");
            socket.off("ice_candidate");
            socket.off("call_ended");
        };
    }, []);

    const handleAccept = async () => {
        if (!incomingCall) return;
        await answerCall(incomingCall.from._id, incomingCall.offer);
        setInCall(true);
    };

    const handleReject = () => {
        socket.emit("end_call", { targetId: incomingCall?.from._id });
        setIncomingCall(null);
    };

    return (
        <Dialog open={!!incomingCall}>
            <DialogContent className="w-[90%] max-w-md text-center space-y-4">
                {inCall ? (
                    <>
                        <h3 className="text-xl font-bold">Đang gọi với {incomingCall?.from.name}</h3>
                        <Button
                            variant="destructive"
                            onClick={() => {
                                endCall(incomingCall!.from._id);
                                setInCall(false);
                                setIncomingCall(null);
                            }}
                            className="w-full"
                        >
                            Kết thúc cuộc gọi
                        </Button>
                    </>
                ) : (
                    <>
                        <img
                            src={incomingCall?.from.imageUrl}
                            alt="caller"
                            className="w-16 h-16 rounded-full mx-auto object-cover"
                        />
                        <h3 className="text-lg font-medium">{incomingCall?.from.name}</h3>
                        <p className="text-muted-foreground text-sm">Cuộc gọi đến...</p>

                        <div className="flex justify-center gap-4 pt-2">
                            <Button
                                variant="secondary"
                                onClick={handleReject}
                                className="flex items-center gap-1"
                            >
                                <X className="w-4 h-4" />
                                Từ chối
                            </Button>
                            <Button
                                onClick={handleAccept}
                                className="flex items-center gap-1"
                            >
                                <Phone className="w-4 h-4" />
                                Trả lời
                            </Button>
                        </div>
                    </>
                )}
            </DialogContent>
        </Dialog>
    );
};

export default VoiceCallDialog;

```

### killigraphy\src\components\ui\badge.tsx
```tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

```

### killigraphy\src\components\ui\button.tsx
```tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

```

### killigraphy\src\components\ui\dialog.tsx
```tsx
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

```

### killigraphy\src\components\ui\form.tsx
```tsx
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-[0.8rem] text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-[0.8rem] font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

```

### killigraphy\src\components\ui\input.tsx
```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

```

### killigraphy\src\components\ui\label.tsx
```tsx
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

```

### killigraphy\src\components\ui\textarea.tsx
```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

```

### killigraphy\src\components\ui\toast.tsx
```tsx
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

```

### killigraphy\src\components\ui\toaster.tsx
```tsx
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

```

### killigraphy\src\constants\index.ts
```ts
export const sidebarLinks = [
    {
        imgURL: "/assets/icons/home.svg",
        route: "/",
        label: "Home",
    },
    {
        imgURL: "/assets/icons/wallpaper.svg",
        route: "/explore",
        label: "Explore",
    },
    {
        imgURL: "/assets/icons/people.svg",
        route: "/all-users",
        label: "People",
    },
    {
        imgURL: "/assets/icons/bookmark.svg",
        route: "/saved",
        label: "Saved",
    },
    {
        imgURL: "/assets/icons/gallery-add.svg",
        route: "/create-post",
        label: "Create Post",
    },
];

export const bottombarLinks = [
    {
        imgURL: "/assets/icons/home.svg",
        route: "/",
        label: "Home",
    },
    {
        imgURL: "/assets/icons/wallpaper.svg",
        route: "/explore",
        label: "Explore",
    },
    {
        imgURL: "/assets/icons/bookmark.svg",
        route: "/saved",
        label: "Saved",
    },
    {
        imgURL: "/assets/icons/gallery-add.svg",
        route: "/create-post",
        label: "Create",
    },
];
```

### killigraphy\src\context\AuthContext.tsx
```tsx
import { getCurrentUser, User } from '@/lib/api';
import { IContextType } from '@/types';
import {
    createContext,
    useContext,
    useEffect,
    useState,
} from 'react';

export const INITIAL_USER = {
    _id: '',
    name: '',
    username: '',
    email: '',
    accountId: '',
    bio: '',
    imageUrl: '',
    createdAt: '',
    updatedAt: '',
};

const INITIAL_STATE: IContextType = {
    user: INITIAL_USER,
    isLoading: false,
    isAuthenticated: false,
    setUser: () => { },
    setIsAuthenticated: () => { },
    checkAuthUser: async () => false as boolean,
};

const AuthContext = createContext<IContextType>(INITIAL_STATE);

const AuthProvider = ({ children }: { children: React.ReactNode }) => {
    const [user, setUser] = useState<User>(INITIAL_USER);
    const [isAuthenticated, setIsAuthenticated] = useState(false);
    const [isLoading, setIsLoading] = useState(true);

    const checkAuthUser = async () => {
        try {
            setIsLoading(true);

            const currentUser = await getCurrentUser();

            if (currentUser) {
                setUser(currentUser);
                setIsAuthenticated(true);
                return true;
            }

            return false;
        } catch (error) {
            console.error('checkAuthUser failed:', error);
            return false;
        } finally {
            setIsLoading(false);
        }
    };

    // Kiểm tra auth khi load lại trang
    useEffect(() => {
        checkAuthUser();
    }, []);

    const value: IContextType = {
        user,
        isLoading,
        isAuthenticated,
        setUser,
        setIsAuthenticated,
        checkAuthUser,
    };

    return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export default AuthProvider;
export const useUserContext = () => useContext(AuthContext);

```

### killigraphy\src\hooks\use-toast.ts
```ts
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

```

### killigraphy\src\hooks\useChatSocket.ts
```ts
// src/hooks/useChatSocket.ts
import { useEffect } from "react";
import socket from "@/lib/socket";
import { useUserContext } from "@/context/AuthContext";

type Props = {
    chatId: string;
    onMessage?: (msg: any) => void;
    onSeen?: (data: any) => void;
    onTyping?: (userId: string) => void;
    onStopTyping?: (userId: string) => void;
};

export const useChatSocket = ({
    chatId,
    onMessage,
    onSeen,
    onTyping,
    onStopTyping,
}: Props) => {
    const { user } = useUserContext();

    useEffect(() => {
        if (!chatId || !user._id) return;

        socket.emit("join_chat", chatId);

        socket.on("new_message", (msg: any) => {
            if (onMessage) onMessage(msg);
        });

        socket.on("message_seen", (data: any) => {
            if (onSeen) onSeen(data);
        });

        socket.on("user_typing", ({ userId }: { userId: string }) => {
            if (onTyping) onTyping(userId);
        });

        socket.on("user_stop_typing", ({ userId }: { userId: string }) => {
            if (onStopTyping) onStopTyping(userId);
        });

        return () => {
            socket.emit("leave_chat", chatId);
            socket.off("new_message");
            socket.off("message_seen");
            socket.off("user_typing");
            socket.off("user_stop_typing");
        };
    }, [chatId, user._id]);
};

```

### killigraphy\src\hooks\useDebounce.ts
```ts
import { useEffect, useState } from "react";

function useDebounce<T>(value: T, delay: number = 500): T {
    const [debouncedValue, setDebouncedValue] = useState<T>(value);

    useEffect(() => {
        const handler = setTimeout(() => setDebouncedValue(value), delay);

        return () => clearTimeout(handler);
    }, [value, delay]);

    return debouncedValue;
}

export default useDebounce;

```

### killigraphy\src\hooks\useVoiceCall.ts
```ts
// hooks/useVoiceCall.ts
import { useRef } from "react";
import socket from "@/lib/socket";

export const useVoiceCall = () => {
    const peerConnection = useRef<RTCPeerConnection | null>(null);
    const localStream = useRef<MediaStream | null>(null);

    const setupMedia = async () => {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        localStream.current = stream;
        return stream;
    };

    const startCall = async (targetId: string, currentUserId: string) => {
        await setupMedia();
        peerConnection.current = new RTCPeerConnection();

        localStream.current?.getTracks().forEach(track => {
            peerConnection.current?.addTrack(track, localStream.current!);
        });

        peerConnection.current.onicecandidate = (e) => {
            if (e.candidate) {
                socket.emit("ice_candidate", {
                    targetId,
                    candidate: e.candidate,
                });
            }
        };

        const offer = await peerConnection.current.createOffer();
        await peerConnection.current.setLocalDescription(offer);

        socket.emit("call_user", {
            targetId,
            from: currentUserId,
            offer,
        });
    };

    const answerCall = async (from: string, offer: RTCSessionDescriptionInit) => {
        await setupMedia();
        peerConnection.current = new RTCPeerConnection();

        localStream.current?.getTracks().forEach(track => {
            peerConnection.current?.addTrack(track, localStream.current!);
        });

        peerConnection.current.onicecandidate = (e) => {
            if (e.candidate) {
                socket.emit("ice_candidate", {
                    targetId: from,
                    candidate: e.candidate,
                });
            }
        };

        await peerConnection.current.setRemoteDescription(offer);
        const answer = await peerConnection.current.createAnswer();
        await peerConnection.current.setLocalDescription(answer);

        socket.emit("answer_call", {
            targetId: from,
            answer,
        });
    };

    const handleAnswer = (answer: RTCSessionDescriptionInit) => {
        peerConnection.current?.setRemoteDescription(answer);
    };

    const handleRemoteCandidate = (candidate: RTCIceCandidateInit) => {
        peerConnection.current?.addIceCandidate(new RTCIceCandidate(candidate));
    };

    const endCall = (targetId: string) => {
        peerConnection.current?.close();
        socket.emit("end_call", { targetId });
    };

    return {
        startCall,
        answerCall,
        handleAnswer,
        handleRemoteCandidate,
        endCall,
        localStream,
    };
};

```

### killigraphy\src\types\index.ts
```ts
import { User } from "@/lib/api";

export type INavLink = {
    imgURL: string;
    route: string;
    label: string;
};

export type IUpdateUser = {
    userId: string;
    name: string;
    bio: string;
    imageId: string;
    imageUrl: URL | string;
    file: File[];
};

export type INewPost = {
    userId: string;
    caption: string;
    file: File[];
    location?: string;
    tags?: string;
};

export type IUpdatePost = {
    postId: string;
    caption: string;
    imageId: string;
    imageUrl: URL;
    file: File[];
    location?: string;
    tags?: string;
};

export type IUser = {
    id: string;
    name: string;
    username: string;
    email: string;
    imageUrl: string;
    bio: string;
};

export type INewUser = {
    name: string;
    email: string;
    username: string;
    password: string;
};

export type IContextType = {
    user: User;
    isLoading: boolean;
    isAuthenticated: boolean;
    setUser: React.Dispatch<React.SetStateAction<User>>;
    setIsAuthenticated: React.Dispatch<React.SetStateAction<boolean>>;
    checkAuthUser: () => Promise<boolean>;
};
```

### killigraphy\src\types\shared.ts
```ts
// types/shared.ts

export interface PopulatedUser {
    _id: string;
    name: string;
    imageUrl: string;
}

export interface PopulatedComment {
    _id: string;
    content: string;
    user: PopulatedUser;
    post: string;
    parent?: string;
    createdAt: string | Date;
    updatedAt: string | Date;
}

```

### killigraphy\src\_auth\AuthLayout.tsx
```tsx
import { Outlet, Navigate } from "react-router-dom";

const AuthLayout = () => {
    const isAuthenticated = false; // Replace with actual authentication logic
    return (
        <>
            {isAuthenticated ? (
                <Navigate to="" />
            ) : (
                <div className="flex h-screen">
                    {/* Left: Form Section */}
                    <section className="flex flex-1 flex-col items-center justify-center bg-black relative z-10">
                        <Outlet />
                    </section>

                    {/* Right: Background Section */}
                    <div className="hidden xl:block relative w-1/2 h-full">
                        <img
                            src="/assets/images/sidebar.jpg"
                            alt="Background"
                            className="h-full w-full object-cover"
                        />
                        {/* Gradient Blend */}
                        <div className="absolute inset-0 bg-gradient-to-l from-transparent to-black/80" />
                        {/* Optional: thêm lớp mờ nhẹ trên ảnh */}
                        <div className="absolute inset-0 bg-black/30" />
                    </div>
                </div>
            )}
        </>
    );
};

export default AuthLayout;

```

### killigraphy\src\_auth\forms\SigninForm.tsx
```tsx
import * as z from "zod";
import { useForm } from "react-hook-form";
import { Link, useNavigate } from "react-router-dom";
import { zodResolver } from "@hookform/resolvers/zod";

import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import Loader from "@/components/shared/Loader";

import { SigninValidation } from "@/lib/validation";
import { useUserContext } from "@/context/AuthContext";
import { useToast } from "@/hooks/use-toast";
import { useSignInAccountMutation } from "@/lib/react-query/QueriesAndMutations";

function SigninForm() {
    const { toast } = useToast();
    const navigate = useNavigate();
    const { checkAuthUser, isLoading: isUserLoading } = useUserContext();


    const form = useForm<z.infer<typeof SigninValidation>>({
        resolver: zodResolver(SigninValidation),
        defaultValues: {
            email: "",
            password: ""
        },
    });

    const {
        mutateAsync: signInAccount,
        isPending: isSigningInUser,
    } = useSignInAccountMutation();

    const handleSignin = async (user: z.infer<typeof SigninValidation>) => {
        try {
            await signInAccount({
                email: user.email,
                password: user.password,
            });

            const isAuthenticated = await checkAuthUser();

            if (isAuthenticated) {
                form.reset();
                navigate("/home");
            } else {
                toast({
                    title: "Login failed",
                    description: "Authentication failed after login.",
                    variant: "destructive",
                });
                navigate("/sign-in");
            }
        } catch (error: any) {
            const message =
                error?.response?.data?.message ||
                error?.message ||
                "Error signing in. Please try again.";

            toast({
                title: "Sign in error",
                description: message,
                variant: "destructive",
            });
        }
    };

    return (
        <Form {...form}>
            <div className="sm:w-420 flex-center flex-col">
                <img src="/assets/images/lo_go_remove_bg.png" alt="logo" />

                <h2 className="h3-bold md:h2-bold pt-5 sm:pt-12">
                    Log in to your account
                </h2>
                <p className="text-light-3 small-medium md:base-regular mt-2">
                    Welcome back! Please enter your details.
                </p>

                <form
                    onSubmit={form.handleSubmit(handleSignin)}
                    className="flex flex-col gap-5 w-full mt-4"
                >
                    <FormField
                        control={form.control}
                        name="email"
                        render={({ field }) => (
                            <FormItem>
                                <FormLabel className="shad-form_label">Email</FormLabel>
                                <FormControl>
                                    <Input type="email" className="shad-input" {...field} />
                                </FormControl>
                                <FormMessage />
                            </FormItem>
                        )}
                    />

                    <FormField
                        control={form.control}
                        name="password"
                        render={({ field }) => (
                            <FormItem>
                                <FormLabel className="shad-form_label">Password</FormLabel>
                                <FormControl>
                                    <Input type="password" className="shad-input" {...field} />
                                </FormControl>
                                <FormMessage />
                            </FormItem>
                        )}
                    />

                    <Button
                        type="submit"
                        className="shad-button_primary"
                        disabled={isSigningInUser || isUserLoading}
                    >
                        {isSigningInUser || isUserLoading ? <Loader /> : "Sign In"}
                    </Button>

                    <p className="text-small-regular text-light-2 text-center mt-2">
                        Don't have an account?
                        <Link
                            to="/sign-up"
                            className="text-primary-500 text-small-semibold ml-1"
                        >
                            Sign Up
                        </Link>
                    </p>
                </form>
            </div>
        </Form>
    );
}

export default SigninForm;

```

### killigraphy\src\_auth\forms\SignupForm.tsx
```tsx
import * as z from "zod";
import { useForm } from "react-hook-form";
import { Link, useNavigate } from "react-router-dom";
import { zodResolver } from "@hookform/resolvers/zod";

import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import Loader from "@/components/shared/Loader";

import { SignupValidation } from "@/lib/validation";
import { useUserContext } from "@/context/AuthContext";
import { useToast } from "@/hooks/use-toast";
import { useCreateUserAccountMutation, useRequestOtpMutation, useVerifyOtpMutation } from "@/lib/react-query/QueriesAndMutations";
import { useEffect, useState } from "react";

const SignupForm = () => {
    const { toast } = useToast();
    const navigate = useNavigate();
    const { checkAuthUser, isLoading: isUserLoading } = useUserContext();

    const [otp, setOtp] = useState('');
    const [isOtpSent, setIsOtpSent] = useState(false);
    const [isOtpVerified] = useState(false);
    const [resendCountdown, setResendCountdown] = useState(0);

    const form = useForm<z.infer<typeof SignupValidation>>({
        resolver: zodResolver(SignupValidation),
        defaultValues: {
            name: "",
            username: "",
            email: "",
            password: "",
        },
    });

    // Queries
    const { mutateAsync: createUserAccount, isPending: isCreatingAccount } = useCreateUserAccountMutation();
    const { mutateAsync: requestOtp, isPending: isSendingOtp } = useRequestOtpMutation();
    const { mutateAsync: verifyOtp } = useVerifyOtpMutation();

    const handleSendOtp = async () => {
        const email = form.getValues("email");

        if (!email) {
            toast({ title: "Email & Password required", variant: "destructive" });
            return;
        }

        try {
            await requestOtp({ email });

            toast({ title: "OTP sent", description: "Please check your email" });
            setIsOtpSent(true);
            setResendCountdown(30); // 30s cooldown
        } catch (error: any) {
            toast({
                title: "Failed to send OTP",
                description: error?.response?.data?.message || "Try again later",
                variant: "destructive",
            });
        }
    };

    useEffect(() => {
        if (resendCountdown <= 0) return;

        const timer = setTimeout(() => {
            setResendCountdown((prev) => prev - 1);
        }, 1000);

        return () => clearTimeout(timer);
    }, [resendCountdown]);

    // Handler
    const handleSignup = async (user: z.infer<typeof SignupValidation>) => {
        try {
            const email = form.getValues("email");

            const res = await verifyOtp({ email, otp }) as { verified: boolean };

            if (!res.verified) {
                toast({ title: "Invalid OTP", variant: "destructive" });
                return;
            }

            await createUserAccount(user);

            const isLoggedIn = await checkAuthUser();
            if (isLoggedIn) {
                form.reset();
                navigate("/home");
            } else {
                toast({ title: "Login failed. Please try again." });
                navigate("/sign-in");
            }
        } catch (error: any) {
            const message =
                error?.response?.data?.message ||
                error?.message ||
                "Sign up failed. Please try again.";

            toast({
                title: "Sign up error",
                description: message,
                variant: "destructive",
            });
        }
    };

    return (
        <Form {...form}>
            <div className="sm:w-420 flex-center flex-col">
                <img src="/assets/images/lo_go_remove_bg.png" alt="logo" />

                <h2 className="h3-bold md:h2-bold pt-5 sm:pt-12">
                    Create a new account
                </h2>
                <p className="text-light-3 small-medium md:base-regular mt-2">
                    To use snapgram, Please enter your details
                </p>

                <form
                    onSubmit={form.handleSubmit(handleSignup)}
                    className="flex flex-col gap-5 w-full mt-4">
                    <FormField
                        control={form.control}
                        name="name"
                        render={({ field }) => (
                            <FormItem>
                                <FormLabel className="shad-form_label">Name</FormLabel>
                                <FormControl>
                                    <Input type="text" className="shad-input" {...field} />
                                </FormControl>
                                <FormMessage />
                            </FormItem>
                        )}
                    />

                    <FormField
                        control={form.control}
                        name="username"
                        render={({ field }) => (
                            <FormItem>
                                <FormLabel className="shad-form_label">Username</FormLabel>
                                <FormControl>
                                    <Input type="text" className="shad-input" {...field} />
                                </FormControl>
                                <FormMessage />
                            </FormItem>
                        )}
                    />

                    <FormField
                        control={form.control}
                        name="email"
                        render={({ field }) => (
                            <FormItem>
                                <FormLabel className="shad-form_label">Email</FormLabel>
                                <FormControl>
                                    <Input type="text" className="shad-input" {...field} />
                                </FormControl>
                                <FormMessage />
                            </FormItem>
                        )}
                    />

                    <FormField
                        control={form.control}
                        name="password"
                        render={({ field }) => (
                            <FormItem>
                                <FormLabel className="shad-form_label">Password</FormLabel>
                                <FormControl>
                                    <Input type="password" className="shad-input" {...field} />
                                </FormControl>
                                <FormMessage />
                            </FormItem>
                        )}
                    />

                    {/* OTP Input + Button */}
                    {isOtpSent && (
                        <div className="flex flex-row gap-2" >
                            <Input
                                placeholder="Enter 6-digit OTP"
                                value={otp}
                                onChange={(e) => setOtp(e.target.value)}
                                maxLength={6}
                                className="tracking-widest text-center"
                                disabled={isOtpVerified}
                            />

                            <Button
                                type="button"
                                variant="secondary"
                                className={
                                    `text-sm px-3 py-1 border rounded-md font-medium
                                    ${resendCountdown > 0 ? "shad-button_primary_ghost" : "shad-button_primary"}
                                    `}
                                onClick={handleSendOtp}
                                disabled={resendCountdown > 0}
                            >
                                {resendCountdown > 0 ? `Send Again (${resendCountdown})` : "Send Again"}
                            </Button>


                        </div>
                    )}

                    {/* Gửi mã OTP hoặc Đăng nhập */}
                    {!isOtpSent ? (
                        <Button type="button" className="shad-button_primary" onClick={() => handleSendOtp()} disabled={isSendingOtp || isCreatingAccount}>
                            {isSendingOtp ? <Loader /> : "Send OTP"}
                        </Button>
                    ) : (
                        <Button
                            type="submit"
                            className="shad-button_primary"
                            disabled={isCreatingAccount || isUserLoading}
                        >
                            {isCreatingAccount || isUserLoading ? <Loader /> : "Verify OTP & Sign Up"}
                        </Button>
                    )}

                    <p className="text-small-regular text-light-2 text-center mt-2">
                        Already have an account?
                        <Link
                            to="/sign-in"
                            className="text-primary-500 text-small-semibold ml-1">
                            Log in
                        </Link>
                    </p>
                </form>
            </div>
        </Form>
    );
};

export default SignupForm;
```

### killigraphy\src\_root\RootLayout.tsx
```tsx
import BottomBar from '@/components/shared/Bottombar';
import LeftSideBar from '@/components/shared/LeftSidebar';
import Loader from '@/components/shared/Loader';
import Topbar from '@/components/shared/Topbar';
import { useUserContext } from '@/context/AuthContext';
import { Navigate, Outlet } from 'react-router-dom';

const RootLayout = () => {
  const {
    isAuthenticated,
    isLoading
  } = useUserContext();

  if (isLoading) return <div className="text-center mt-10"><Loader /></div>;
  if (!isAuthenticated) return <Navigate to="/sign-in" replace />;

  return (
    <div className='w-full md:flex'>
      <Topbar />
      <LeftSideBar />

      <section className='flex flex-1 h-full'>
        <Outlet /> {/* This is where the child routes will be rendered. Outllet is a placeholder for the child routes. */}
      </section>

      <BottomBar />
    </div>
  )
}

export default RootLayout;
```

### killigraphy\src\_root\pages\AllUsers.tsx
```tsx
import { useToast } from "@/hooks/use-toast";
import { useInfiniteUsersMutation } from "@/lib/react-query/QueriesAndMutations";
import UserList from "@/components/shared/UserList";
import { useState, useMemo } from "react";
import { User } from "@/lib/api";
import Loader from "@/components/shared/Loader";

type FollowState = {
    initial: boolean;
    current: boolean;
};

const AllUsers = () => {
    const { toast } = useToast();
    const {
        data,
        fetchNextPage,
        hasNextPage,
        isFetchingNextPage,
        isPending: isLoading,
        isError,
    } = useInfiniteUsersMutation();

    const [localFollowMap, setLocalFollowMap] = useState<Record<string, FollowState>>({});

    const flatUsers = useMemo(() => data?.pages.flat() ?? [], [data]);

    const [searchTerm, setSearchTerm] = useState("");

    const filteredUsers = useMemo(() => {
        return flatUsers.filter((u) =>
            u.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            u.username.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [searchTerm, flatUsers]);

    const handleInitFollowState = (users: User[]) => {
        const map: Record<string, FollowState> = {};
        users.forEach((u) => {
            map[u._id] = { initial: false, current: false }; // all are not followed initially
        });
        setLocalFollowMap(map);
    };

    const toggleLocalFollow = (userId: string) => {
        setLocalFollowMap((prev) => ({
            ...prev,
            [userId]: {
                ...prev[userId],
                current: !prev[userId].current,
            },
        }));
    };

    if (isError) {
        toast({
            title: "Error",
            description: "Something went wrong while fetching users.",
            variant: "destructive",
        });
        return <div>Error fetching users</div>;
    }

    return (
        <div className="common-container">
            <div className="user-container">
                <div className="flex flex-col gap-4 w-full">
                    {/* Header with icon + title */}
                    <div className="flex items-center gap-3">
                        <h2 className="h3-bold md:h2-bold text-white">Discover New People</h2>
                    </div>

                    {/* Search input */}
                    <input
                        type="text"
                        placeholder="Search users..."
                        value={searchTerm}
                        onChange={(e) => setSearchTerm(e.target.value)}
                        className="w-full px-4 py-2 rounded-lg bg-dark-4 text-light-1 placeholder:text-light-3 outline-none"
                    />
                </div>

                {/* User list */}
                {isLoading && !data ? (
                    <Loader />
                ) : flatUsers.length === 0 ? (
                    <p className="text-light-4 mt-10 text-center w-full">No people found.</p>
                ) : (
                    <UserList
                        userId="dummy"
                        type="suggestions"
                        layout="grid"
                        overrideUsers={filteredUsers}
                        localFollowMap={localFollowMap}
                        onInitFollowState={handleInitFollowState}
                        onToggleFollow={toggleLocalFollow}
                        enableInfiniteScroll
                        onLoadMore={fetchNextPage}
                        hasMore={hasNextPage}
                        isLoadingMore={isFetchingNextPage}
                    />
                )}
            </div>
        </div>
    );
};

export default AllUsers;

```

### killigraphy\src\_root\pages\CreatePost.tsx
```tsx
import PostForm from "@/components/forms/PostForm"
import { useLocation } from "react-router-dom";

const CreatePost = () => {
    const location = useLocation();
    const prefillCaption = location.state?.prefillCaption || "";
    const prefillFile = location.state?.prefillFile || null;
    return (
        <div className="flex flex-1">
            <div className="common-container">
                <div className="max-w-5xl flex-start gap-3 justify-start w-full">
                    <img
                        src='/assets/icons/add-post.svg'
                        alt='create-post'
                        className="w-10 h-10"
                    />
                    <h2 className="h3-bold md:h2-bold text-left w-full">
                        Create Post
                    </h2>
                </div>
                <PostForm action="Create" prefillCaption={prefillCaption} prefillFile={prefillFile} />
            </div>
        </div>
    )
}

export default CreatePost
```

### killigraphy\src\_root\pages\EditPost.tsx
```tsx
import PostForm from "@/components/forms/PostForm"
import Loader from "@/components/shared/Loader"
import { useGetPostByIdMutation } from "@/lib/react-query/QueriesAndMutations"
import { useParams } from "react-router-dom"

const EditPost = () => {
    const { postId } = useParams() as { postId: string }
    const { data: post, isPending, isError } = useGetPostByIdMutation(postId)

    if (!postId) return <div className="text-red-500">Post ID not found</div>;
    if (isPending) return <div className="flex flex-1"><Loader /></div>;
    if (isError || !post) return <div className="text-red-500">Failed to load post</div>;

    if (isPending) return <div className="flex flex-1"><Loader /></div>

    return (
        <div className="flex flex-1">
            <div className="common-container">
                <div className="max-w-5xl flex-start gap-3 justify-start w-full">
                    <img
                        src='/assets/icons/add-post.svg'
                        alt='create-post'
                        className="w-10 h-10"
                    />
                    <h2 className="h3-bold md:h2-bold text-left w-full">
                        Edit Post
                    </h2>
                </div>
                <PostForm action="Update" post={post} />
            </div>
        </div>
    )
}

export default EditPost
```

### killigraphy\src\_root\pages\Explore.tsx
```tsx
import { useEffect, useState } from "react";
import { useInView } from "react-intersection-observer";
import GridPostList from "@/components/shared/GridPostList";
import Loader from "@/components/shared/Loader";
import { Input } from "@/components/ui/input";
import useDebounce from "@/hooks/useDebounce";
import {
    useInfinitePostsMutation,
    usePostMetaMutation,
    useSearchPostsMutation,
} from "@/lib/react-query/QueriesAndMutations";

const Explore = () => {
    const [searchValue, setSearchValue] = useState("");
    const debouncedQuery = useDebounce(searchValue, 500);
    const { data: postMeta } = usePostMetaMutation();
    const tagOptions = postMeta?.pages?.[0]?.tags || [];
    const locationOptions = postMeta?.pages?.[0]?.locations || [];

    const [showAllTags, setShowAllTags] = useState(false);
    const MAX_VISIBLE_TAGS = 10;
    const visibleTags = showAllTags ? tagOptions : tagOptions.slice(0, MAX_VISIBLE_TAGS);

    const [filters, setFilters] = useState({
        tags: [] as string[],
        location: "",
        sort: "latest",
    });

    const {
        data: infinitePosts,
        fetchNextPage,
        hasNextPage,
        isPending: isFetchingPosts,
    } = useInfinitePostsMutation();

    const { ref, inView } = useInView();

    const {
        data: searchResults,
        isPending: isSearching,
    } = useSearchPostsMutation({
        query: debouncedQuery.trim(),
        tags: filters.tags,
        location: filters.location,
        sort: filters.sort as "latest" | "popular",
    });

    const shouldShowSearch =
        !!debouncedQuery || filters.tags.length > 0 || !!filters.location;

    useEffect(() => {
        if (inView && !shouldShowSearch && hasNextPage) {
            fetchNextPage();
        }
    }, [inView, shouldShowSearch, hasNextPage]);

    const toggleTag = (tag: string) => {
        setFilters((prev) => {
            const exists = prev.tags.includes(tag);
            return {
                ...prev,
                tags: exists ? prev.tags.filter((t) => t !== tag) : [...prev.tags, tag],
            };
        });
    };

    return (
        <div className="explore-container px-4 py-6 min-h-screen">
            <div className="max-w-6xl mx-auto">
                <h2 className="h2-bold text-left mb-6">Explore</h2>

                {/* Search Bar */}
                <div className="flex gap-3 items-center bg-dark-3 rounded-xl px-4 py-3 mb-6">
                    <img src="/assets/icons/search.svg" alt="search" className="w-5 h-5 opacity-70" />
                    <Input
                        type="text"
                        placeholder="Tìm kiếm..."
                        className="bg-transparent text-white border-none focus-visible:ring-0"
                        value={searchValue}
                        onChange={(e) => setSearchValue(e.target.value)}
                    />
                </div>

                {/* Filters Section */}
                <div className="bg-dark-2 rounded-xl p-5 space-y-4 shadow-md">
                    <div className="flex flex-wrap items-center gap-4">
                        <select
                            className="bg-dark-3 text-light-2 px-3 py-2 rounded-md"
                            value={filters.sort}
                            onChange={(e) => setFilters({ ...filters, sort: e.target.value })}
                        >
                            <option value="latest">Latest</option>
                            <option value="popular">Popular</option>
                        </select>

                        <select
                            className="bg-dark-3 text-light-2 px-3 py-2 rounded-md"
                            value={filters.location}
                            onChange={(e) => setFilters({ ...filters, location: e.target.value })}
                        >
                            <option value="">All Location</option>
                            {locationOptions.map((loc) => (
                                <option key={loc} value={loc}>
                                    {loc.length > 18 ? loc.slice(0, 15) + "..." : loc}
                                </option>
                            ))}
                        </select>
                    </div>

                    {/* Tags */}
                    <div className="space-y-3">
                        <div className="flex flex-wrap gap-2 transition-all duration-300 overflow-hidden">
                            {visibleTags.map((tag) => (
                                <button
                                    key={tag}
                                    onClick={() => toggleTag(tag)}
                                    className={`px-3 py-1 rounded-full text-sm whitespace-nowrap border ${filters.tags.includes(tag)
                                        ? "bg-primary-500 text-white"
                                        : "bg-dark-3 text-light-2"
                                        }`}
                                >
                                    #{tag}
                                </button>
                            ))}
                        </div>

                        {tagOptions.length > MAX_VISIBLE_TAGS && (
                            <button
                                onClick={() => setShowAllTags(!showAllTags)}
                                className="text-sm text-light-4 underline"
                            >
                                {showAllTags ? "Ẩn bớt" : "Xem thêm"}
                            </button>
                        )}
                    </div>
                </div>

                {/* Results */}
                <div className="mt-10">
                    {shouldShowSearch ? (
                        isSearching ? (
                            <Loader />
                        ) : searchResults?.length ? (
                            <GridPostList posts={searchResults} />
                        ) : (
                            <p className="text-light-4 text-center mt-10"> No results found for your search.</p>
                        )
                    ) : isFetchingPosts ? (
                        <Loader />
                    ) : (
                        infinitePosts?.pages.map((group, i) => (
                            <GridPostList key={`page-${i}`} posts={group.posts} />
                        ))
                    )}

                    {hasNextPage && !shouldShowSearch && (
                        <div ref={ref} className="mt-6 flex justify-center">
                            <Loader />
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default Explore;

```

### killigraphy\src\_root\pages\Home.tsx
```tsx
import { useEffect, useRef } from 'react';
import Loader from '@/components/shared/Loader';
import PostCard from '@/components/shared/PostCard';
import { Post } from '@/lib/api';
import { useGetFeedPersonalizedMutation } from '@/lib/react-query/QueriesAndMutations';

const Home = () => {
  const {
    data,
    isPending,
    isError,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useGetFeedPersonalizedMutation();

  const posts = data?.pages.flat() ?? [];

  // Use IntersectionObserver instead of scroll event
  const loaderRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasNextPage && !isFetchingNextPage) {
          fetchNextPage();
        }
      },
      { threshold: 1 }
    );

    const current = loaderRef.current;
    if (current) observer.observe(current);

    return () => {
      if (current) observer.unobserve(current);
    };
  }, [hasNextPage, isFetchingNextPage]);

  return (
    <div className='flex flex-1'>
      <div className='home-container'>
        <div className='home-posts'>
          <h2 className='h3-bold md:h2-bold text-left w-full'>Home Feed</h2>

          {isPending && posts.length === 0 ? (
            <Loader />
          ) : (
            <ul className='flex flex-col flex-1 gap-9 w-full'>
              {posts.length === 0 && (
                <p className='text-light-4'>No available posts</p>
              )}
              {posts.map((post: Post) => (
                <PostCard key={post._id} post={post} />
              ))}
            </ul>
          )}

          {isFetchingNextPage && (
            <div className="mt-4">
              <Loader />
            </div>
          )}

          {isError && <p className="text-red-500 mt-4">Failed to load posts.</p>}

          {/* Ref target for lazy loading */}
          <div ref={loaderRef} className="h-10" />
        </div>
      </div>
    </div>
  );
};

export default Home;

```

### killigraphy\src\_root\pages\index.ts
```ts
export { default as Home } from "./Home";
export { default as Explore } from "./Explore";
export { default as Saved } from "./Saved";
export { default as CreatePost } from "./CreatePost";
export { default as Profile } from "./Profile";
export { default as UpdateProfile } from "./UpdateProfile";
export { default as EditPost } from "./EditPost";
export { default as PostDetails } from "./PostDetails";
export { default as LikedPosts } from "./LikedPosts";
export { default as AllUsers } from "./AllUsers";
```

### killigraphy\src\_root\pages\LikedPosts.tsx
```tsx
import GridPostList from "@/components/shared/GridPostList";
import Loader from "@/components/shared/Loader";
import { useUserContext } from "@/context/AuthContext";
import { Post } from "@/lib/api";
import { useGetListPostsMutation } from "@/lib/react-query/QueriesAndMutations";

const LikedPosts = () => {
    const { user } = useUserContext();

    const { data: likedPosts, isPending } = useGetListPostsMutation(user?.likedPosts ?? []);

    if (!user || isPending) {
        return (
            <div className="flex-center w-full h-full">
                <Loader />
            </div>
        );
    }

    if (!likedPosts || likedPosts.length === 0) {
        return <p className="text-light-4">No liked posts</p>;
    }

    return (
        <GridPostList posts={likedPosts as Post[]} showStats={false} />
    );
};

export default LikedPosts;

```

### killigraphy\src\_root\pages\PostDetails.tsx
```tsx
import GridPostList from "@/components/shared/GridPostList"
import Loader from "@/components/shared/Loader"
import PostComments from "@/components/shared/PostComments"
import PostStats from "@/components/shared/PostStats"
import { Button } from "@/components/ui/button"
import { useUserContext } from "@/context/AuthContext"
import { useDeletePostMutation, useGetPostByIdMutation, useGetUserPostsMutation } from "@/lib/react-query/QueriesAndMutations"
import { multiFormatDateString } from "@/lib/utils"
import { Link, useNavigate, useParams } from "react-router-dom"

const PostDetails = () => {
    const { postId } = useParams<{ postId: string }>()
    const { data: post, isPending } = useGetPostByIdMutation(postId as string)
    const { data: userPosts, isLoading: isUserPostLoading } = useGetUserPostsMutation(
        post?.creator._id as string
    );
    const { mutate: deletePost } = useDeletePostMutation()
    const relatedPosts = userPosts?.filter((userPost) => userPost._id !== postId)
    const { user } = useUserContext()
    const navigate = useNavigate()

    const handleDeletePost = () => {
        if (postId) {
            deletePost(postId)
            navigate("/home")
        }
    }

    return (
        <div className="post_details-container">
            <div className="hidden md:flex max-w-5xl w-full">
                <Button
                    onClick={() => navigate(-1)}
                    variant="ghost"
                    className="shad-button_ghost">
                    <img
                        src={"/assets/icons/back.svg"}
                        alt="back"
                        width={24}
                        height={24}
                    />
                    <p className="small-medium lg:base-medium">Back</p>
                </Button>
            </div>

            {isPending || !post ? (
                <Loader />
            ) : (
                <div className="post_details-card">
                    <img
                        src={post?.imageURL}
                        alt="creator"
                        className="post_details-img"
                    />

                    <div className="post_details-info">
                        <div className="flex-between w-full">
                            <Link
                                to={`/profile/${post?.creator._id}`}
                                className="flex items-center gap-3">
                                <img
                                    src={
                                        post.creator.imageUrl?.startsWith("https://ik.imagekit.io/killigraphy/avatars/avatar")
                                            ? "/assets/icons/profile-placeholder.svg"
                                            : user.imageUrl || "/assets/icons/profile-placeholder.svg"
                                    }
                                    alt="creator"
                                    className="w-8 h-8 lg:w-12 lg:h-12 rounded-full"
                                />
                                <div className="flex gap-1 flex-col">
                                    <p className="base-medium lg:body-bold text-light-1">
                                        {post?.creator.name}
                                    </p>
                                    <div className="flex-center gap-2 text-light-3">
                                        <p className="subtle-semibold lg:small-regular ">
                                            {multiFormatDateString(post?.createdAt)}
                                        </p>
                                        •
                                        <p className="subtle-semibold lg:small-regular">
                                            {post?.location}
                                        </p>
                                    </div>
                                </div>
                            </Link>

                            <div className="flex-center gap-4">
                                <Link
                                    to={`/update-post/${post?._id}`}
                                    className={`${user._id !== post?.creator._id && "hidden"}`}>
                                    <img
                                        src={"/assets/icons/edit.svg"}
                                        alt="edit"
                                        width={24}
                                        height={24}
                                    />
                                </Link>

                                <Button
                                    onClick={handleDeletePost}
                                    variant="ghost"
                                    className={`ost_details-delete_btn ${user._id !== post?.creator._id && "hidden"
                                        }`}>
                                    <img
                                        src={"/assets/icons/delete.svg"}
                                        alt="delete"
                                        width={24}
                                        height={24}
                                    />
                                </Button>
                            </div>
                        </div>

                        <hr className="border w-full border-dark-4/80" />

                        <div className="flex flex-col flex-1 w-full small-medium lg:base-regular">
                            <p>{post?.caption}</p>
                            <ul className="flex gap-1 mt-2">
                                {post?.tags.map((tag: string, index: number) => (
                                    <li
                                        key={`${tag}-${index}`}
                                        className="text-light-3 small-regular"
                                    >
                                        #{tag}
                                    </li>
                                ))}
                            </ul>
                        </div>

                        <div className="w-full">
                            <PostStats post={post} userId={user._id} />
                        </div>
                        <div className="w-full">
                            <PostComments postId={post._id} postCreatorId={post?.creator?._id} />
                        </div>
                    </div>
                </div>
            )}

            <div className="w-full max-w-5xl">
                <hr className="border w-full border-dark-4/80" />

                <h3 className="body-bold md:h3-bold w-full my-10">
                    More Related Posts
                </h3>
                {isUserPostLoading || !relatedPosts ? (
                    <Loader />
                ) : (
                    <GridPostList posts={relatedPosts} />
                )}
            </div>
        </div>
    )
}

export default PostDetails
```

### killigraphy\src\_root\pages\Profile.tsx
```tsx
import {
    Route,
    Routes,
    Link,
    Outlet,
    useParams,
    useLocation,
    useNavigate,
} from "react-router-dom";

import { LikedPosts } from "@/_root/pages";
import { useUserContext } from "@/context/AuthContext";
import {
    useFollowersQueryMutation,
    useFollowingQuery,
    useGetUserByIdMutation,
    useGetUserPostsMutation,
    useIsFollowingQueryMutation,
    useToggleFollowMutation,
} from "@/lib/react-query/QueriesAndMutations";
import Loader from "@/components/shared/Loader";
import { Button } from "@/components/ui/button";
import GridPostList from "@/components/shared/GridPostList";

interface StatBlockProps {
    value: string | number;
    label: string;
}

// StatBlock component to display user stats like posts, followers, and following
const StatBlock = ({ value, label, onClick }: StatBlockProps & { onClick?: () => void }) => (
    <div
        className="flex-center gap-2 cursor-pointer"
        onClick={onClick}
    >
        <p className="small-semibold lg:body-bold text-primary-500">{value}</p>
        <p className="small-medium lg:base-medium text-light-2">{label}</p>
    </div>
);

const Profile = () => {
    const { userId } = useParams();
    const { user: currentUser } = useUserContext();
    const { pathname } = useLocation();
    const navigate = useNavigate();

    const { data: profileUser, isLoading: isLoadingProfile } = useGetUserByIdMutation(userId || "");
    const { data: posts = [] } = useGetUserPostsMutation(userId || "");

    const { data: followStatus, isLoading: isCheckingFollow } = useIsFollowingQueryMutation(userId || "", userId !== currentUser._id);
    const { mutateAsync: toggleFollow, isPending: isToggling } = useToggleFollowMutation();

    const { data: followersList = [] } = useFollowersQueryMutation(userId || "");
    const { data: followingList = [] } = useFollowingQuery(userId || "");

    const isSelf = currentUser._id === userId;
    const isFollowing = followStatus?.isFollowing;

    const handleFollow = async (e: React.MouseEvent) => {
        e.preventDefault();
        try {
            await toggleFollow(userId || "");
        } catch (err) {
            console.error("Toggle follow failed:", err);
        }
    };

    if (isLoadingProfile || !profileUser) {
        return (
            <div className="flex-center w-full h-full">
                <Loader />
            </div>
        );
    }

    return (
        <div className="profile-container">
            <div className="profile-inner_container">
                <div className="flex xl:flex-row flex-col max-xl:items-center flex-1 gap-7">
                    <img
                        src={
                            profileUser.imageUrl?.startsWith("https://ik.imagekit.io/killigraphy/avatars/avatar")
                                ? "/assets/icons/profile-placeholder.svg"
                                : profileUser.imageUrl || "/assets/icons/profile-placeholder.svg"
                        }
                        alt="profile"
                        className="w-28 h-28 lg:h-36 lg:w-36 rounded-full"
                    />
                    <div className="flex flex-col flex-1 justify-between md:mt-2">
                        <div className="flex flex-wrap items-center justify-center xl:justify-between gap-4 w-full">
                            <div className="flex flex-col items-center xl:items-start">
                                <h1 className="h3-bold md:h1-semibold text-white">{profileUser.name}</h1>
                                <p className="small-regular md:body-medium text-light-3">@{profileUser.username}</p>
                            </div>

                            {!isSelf ? (
                                <Button
                                    type="button"
                                    size="sm"
                                    className={`px-5 ${isFollowing ? "shad-button_dark_4" : "shad-button_primary_base"}`}
                                    onClick={handleFollow}
                                    disabled={isToggling || isCheckingFollow}
                                >
                                    {isToggling || isCheckingFollow ? "..." : isFollowing ? "Unfollow" : "Follow"}
                                </Button>
                            ) : (
                                <Link
                                    to={`/update-profile/${profileUser._id}`}
                                    className="h-10 bg-dark-4 px-4 text-light-1 flex items-center gap-2 rounded-lg"
                                >
                                    <img src="/assets/icons/edit.svg" alt="edit" width={18} height={18} />
                                    <p className="small-medium whitespace-nowrap">Edit Profile</p>
                                </Link>
                            )}
                        </div>

                        <div className="flex gap-8 mt-10 items-center justify-center xl:justify-start flex-wrap z-20">
                            <StatBlock value={posts.length} label="Posts" />
                            <StatBlock
                                value={followersList?.length || 0}
                                label="Followers"
                                onClick={() =>
                                    navigate(`/profile/${userId}/connections?tab=followers`, {
                                        state: { fromUserId: userId }
                                    })
                                }
                            />

                            <StatBlock
                                value={followingList?.length || 0}
                                label="Following"
                                onClick={() =>
                                    navigate(`/profile/${userId}/connections?tab=following`, {
                                        state: { fromUserId: userId }
                                    })
                                }
                            />
                        </div>

                        <p className="small-medium md:base-medium text-center xl:text-left mt-7 max-w-screen-sm">
                            {profileUser.bio}
                        </p>
                    </div>
                </div>
            </div>

            {isSelf && (
                <div className="flex justify-center w-full mt-6">
                    <div className="flex max-w-5xl w-full justify-center">
                        <Link
                            to={`/profile/${userId}`}
                            className={`profile-tab rounded-l-lg ${pathname === `/profile/${userId}` && "!bg-dark-3"}`}
                        >
                            <img src="/assets/icons/posts.svg" alt="posts" width={20} height={20} />
                            Posts
                        </Link>
                        <Link
                            to={`/profile/${userId}/liked-posts`}
                            className={`profile-tab rounded-r-lg ${pathname === `/profile/${userId}/liked-posts` && "!bg-dark-3"}`}
                        >
                            <img src="/assets/icons/like.svg" alt="like" width={20} height={20} />
                            Liked Posts
                        </Link>
                    </div>
                </div>
            )}

            <Routes>
                <Route index element={<GridPostList posts={posts} showUser={false} showCreatePostCard={isSelf} />} />
                {isSelf && <Route path="liked-posts" element={<LikedPosts />} />}
            </Routes>

            <Outlet />
        </div>
    );
};

export default Profile;

```

### killigraphy\src\_root\pages\ProfileConnections.tsx
```tsx
import { useSearchParams, useParams, useNavigate } from "react-router-dom";
import { useEffect, useMemo, useState } from "react";
import UserList from "@/components/shared/UserList";
import { User } from "@/lib/api";
import { useSuggestedUsersInfiniteQuery, useToggleFollowMutation } from "@/lib/react-query/QueriesAndMutations";
import Loader from "@/components/shared/Loader";

type FollowState = {
    initial: boolean;
    current: boolean;
};

const ProfileConnections = () => {
    const navigate = useNavigate();
    const { userId } = useParams();
    const [searchParams, setSearchParams] = useSearchParams();
    const tab = searchParams.get("tab") as "followers" | "following" | null;

    const [activeTab, setActiveTab] = useState<"followers" | "following">("followers");
    const [localFollowMap, setLocalFollowMap] = useState<Record<string, FollowState>>({});
    const [allUsers, setAllUsers] = useState<User[]>([]);
    const [searchTerm, setSearchTerm] = useState("");

    const { mutateAsync: toggleFollowApi } = useToggleFollowMutation();

    const {
        data: suggestedPages,
        fetchNextPage,
        hasNextPage,
        isFetchingNextPage,
    } = useSuggestedUsersInfiniteQuery(userId!);

    const suggestedUsers = useMemo(
        () => suggestedPages?.pages.flat() ?? [],
        [suggestedPages]
    );

    // Sync các follow thay đổi với backend
    const syncPendingChanges = async () => {
        const entries = Object.entries(localFollowMap);
        for (const [userId, { initial, current }] of entries) {
            if (initial !== current) {
                try {
                    await toggleFollowApi(userId);
                } catch (err) {
                    console.error("Failed to sync follow state for", userId);
                }
            }
        }
    };

    // Đồng bộ khi unmount trang
    useEffect(() => {
        return () => {
            syncPendingChanges();
        };
    }, []);

    // Đồng bộ khi chuyển tab
    const handleTabClick = async (tab: "followers" | "following") => {
        await syncPendingChanges();
        setSearchParams({ tab });
        setSearchTerm("");
    };

    useEffect(() => {
        if (tab === "following" || tab === "followers") {
            setActiveTab(tab);
            setAllUsers([]);
        }
    }, [tab]);

    const handleInitFollowState = (users: User[]) => {
        const map: Record<string, FollowState> = {};
        const defaultFollowState = activeTab === "following" ? true : false;

        users.forEach((u) => {
            const isFollowing = u.isFollowing ?? defaultFollowState;
            map[u._id] = {
                initial: isFollowing,
                current: isFollowing,
            };
        });
        setLocalFollowMap(map);
        setAllUsers(users);
    };

    const handleInitSuggestedFollowState = (users: User[]) => {
        setLocalFollowMap((prev) => {
            const map = { ...prev };
            users.forEach((u) => {
                if (!map[u._id]) {
                    map[u._id] = {
                        initial: u.isFollowing ?? false,
                        current: u.isFollowing ?? false,
                    };
                }
            });
            return map;
        });
    };

    const toggleLocalFollow = (userId: string) => {
        setLocalFollowMap((prev) => {
            const userFollow = prev[userId];
            if (!userFollow) return prev; // 👈 tránh lỗi
            return {
                ...prev,
                [userId]: {
                    ...userFollow,
                    current: !userFollow.current,
                },
            };
        });
    };

    const filteredUsers = useMemo(() => {
        return allUsers.filter((u) =>
            u.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            u.username.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [searchTerm, allUsers]);

    const filteredSuggestedUsers = useMemo(() => {
        return suggestedUsers.filter(
            (u) => !allUsers.some((existing) => existing._id === u._id)
        );
    }, [suggestedUsers, allUsers]);

    const isSearching = searchTerm.trim().length > 0;

    return (
        <div className="common-container">
            <div className="user-container">
                <section className="max-w-3xl w-full mx-auto px-4 py-8">
                    <div className="bg-dark-2 h-full rounded-xl shadow-md p-6">
                        <div className="flex justify-between items-center mb-6">
                            <h1 className="h2-bold text-white">Connections</h1>
                            <button
                                onClick={async () => {
                                    await syncPendingChanges();
                                    navigate(`/profile/${userId}`);
                                }}
                                className="flex items-center gap-2 px-4 py-2 rounded-lg bg-dark-4 hover:bg-dark-3 transition"
                            >
                                <img src="/assets/icons/back.svg" alt="back" className="w-4 h-4" />
                                <span className="text-sm text-light-1">Back to Profile</span>
                            </button>
                        </div>

                        {/* Tabs */}
                        <div className="flex justify-center gap-6 mb-6 border-b border-dark-4 pb-2">
                            {["followers", "following"].map((t) => (
                                <button
                                    key={t}
                                    className={`pb-1 transition font-medium ${activeTab === t
                                        ? "border-b-2 border-primary-500 text-white"
                                        : "text-light-3"
                                        }`}
                                    onClick={() => handleTabClick(t as any)}
                                >
                                    {t.charAt(0).toUpperCase() + t.slice(1)}
                                </button>
                            ))}
                        </div>

                        {/* Search bar */}
                        <div className="mb-4">
                            <input
                                type="text"
                                placeholder={`Search ${activeTab}`}
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                                className="w-full px-4 py-2 rounded-lg bg-dark-4 text-light-1 placeholder:text-light-3 outline-none"
                            />
                        </div>

                        {/* User List */}
                        <UserList
                            userId={userId!}
                            type={activeTab}
                            layout="horizontal"
                            localFollowMap={localFollowMap}
                            onInitFollowState={handleInitFollowState}
                            onToggleFollow={toggleLocalFollow}
                            overrideUsers={isSearching ? filteredUsers : undefined}
                        />

                        {/* Suggestions */}
                        {suggestedUsers.length === 0 && isFetchingNextPage && <Loader />}
                        {suggestedUsers.length > 0 && (
                            <div className="mt-10">
                                <h2 className="h3-bold text-white mb-3">Suggested for you</h2>

                                <UserList
                                    userId={userId!}
                                    type="suggestions"
                                    layout="horizontal"
                                    localFollowMap={localFollowMap}
                                    onInitFollowState={handleInitSuggestedFollowState}
                                    onToggleFollow={toggleLocalFollow}
                                    overrideUsers={filteredSuggestedUsers}
                                    enableInfiniteScroll
                                    onLoadMore={fetchNextPage}
                                    hasMore={hasNextPage}
                                    isLoadingMore={isFetchingNextPage}
                                />
                            </div>
                        )}
                    </div>
                </section>
            </div>
        </div>
    );
};

export default ProfileConnections;

```

### killigraphy\src\_root\pages\Saved.tsx
```tsx
import GridPostList from "@/components/shared/GridPostList";
import Loader from "@/components/shared/Loader";
import { Post } from "@/lib/api";
import { useGetCurrentUserMutation, useGetSavedPostsMutation } from "@/lib/react-query/QueriesAndMutations";


const Saved = () => {
    const { data: currentUser } = useGetCurrentUserMutation();
    const { data: savePosts } = useGetSavedPostsMutation() as { data: Post[] };

    return (
        <div className="saved-container">
            <div className="flex gap-2 w-full max-w-5xl">
                <img
                    src="/assets/icons/save.svg"
                    width={36}
                    height={36}
                    alt="edit"
                    className="invert-white"
                />
                <h2 className="h3-bold md:h2-bold text-left w-full">Saved Posts</h2>
            </div>

            {!currentUser ? (
                <Loader />
            ) : (
                <div className="w-full flex justify-center max-w-5xl gap-9">
                    {!savePosts || savePosts.length === 0 ? (
                        <p className="text-light-4">No available posts</p>
                    ) : (
                        <GridPostList posts={savePosts} showStats={false} />
                    )}
                </div>
            )}
        </div>
    );
};

export default Saved;
```

### killigraphy\src\_root\pages\UpdateProfile.tsx
```tsx
import * as z from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useNavigate } from "react-router-dom";

import {
    Form,
    FormControl,
    FormField,
    FormItem,
    FormLabel,
    FormMessage,
} from "@/components/ui/form";

import { useUserContext } from "@/context/AuthContext";
import { useToast } from "@/hooks/use-toast";
import { UpdateProfileValidation } from "@/lib/validation";
import Loader from "@/components/shared/Loader";
import ProfileUploader from "@/components/shared/ProfileUploader";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import { useUpdateUserMutation } from "@/lib/react-query/QueriesAndMutations";
import { UpdateProfilePayload } from "@/lib/api";
import ChangePasswordDialog from "@/components/shared/ChangePasswordDialog";
import { useState } from "react";

const UpdateProfile = () => {
    const { toast } = useToast();
    const navigate = useNavigate();
    const { user, setUser } = useUserContext();
    const [avatarFile, setAvatarFile] = useState<File | null>(null);
    const [wantToPost, setWantToPost] = useState(false);

    const form = useForm<z.infer<typeof UpdateProfileValidation>>({
        resolver: zodResolver(UpdateProfileValidation),
        defaultValues: {
            file: [],
            name: user.name,
            username: user.username,
            email: user.email,
            bio: user.bio || "",
        },
    });

    const { mutateAsync: updateUser, isPending: isLoadingUpdate } = useUpdateUserMutation();

    const handleUpdate = async (value: z.infer<typeof UpdateProfileValidation>) => {
        const avatar = value.file[0];
        const payload: UpdateProfilePayload = {
            userId: user._id,
            username: value.username,
            name: value.name,
            bio: value.bio,
            file: avatar,
        };

        try {
            const updatedUser = await updateUser(payload);

            if (!updatedUser) {
                toast({
                    title: `Update failed`,
                    description: "Please try again.",
                    variant: "destructive",
                });
                return;
            }

            setUser({
                ...user,
                username: updatedUser.username,
                name: updatedUser.name,
                bio: updatedUser.bio,
                imageUrl: updatedUser.imageUrl,
            });

            toast({ title: "Update successful" });

            if (wantToPost && avatarFile) {
                console.log("Prefill file:", avatar);
                navigate("/create-post", {
                    state: {
                        prefillCaption: "New profile photo",
                        prefillFile: avatarFile,
                    },
                });
            } else {
                navigate(`/profile/${user._id}`);
            }
        } catch (err) {
            toast({
                title: "Update error",
                description: "An error occurred during update.",
                variant: "destructive",
            });
        }
    };

    return (
        <div className="flex flex-1">
            <div className="common-container">
                <div className="flex-start gap-3 justify-start w-full max-w-5xl">
                    <img
                        src="/assets/icons/edit.svg"
                        width={36}
                        height={36}
                        alt="edit"
                        className="invert-white"
                    />
                    <h2 className="h3-bold md:h2-bold text-left w-full">Edit Profile</h2>
                </div>

                <Form {...form}>
                    <form
                        onSubmit={form.handleSubmit(handleUpdate)}
                        className="flex flex-col gap-7 w-full mt-4 max-w-5xl"
                    >
                        <FormField
                            control={form.control}
                            name="file"
                            render={({ field }) => (
                                <FormItem className="flex">
                                    <FormControl>
                                        <ProfileUploader
                                            fieldChange={field.onChange}
                                            mediaUrl={user.imageUrl}
                                            onAvatarConfirmed={(file) => {
                                                setAvatarFile(file);
                                                setWantToPost(true); // Gợi ý người dùng tạo post
                                            }}
                                        />
                                    </FormControl>
                                    <FormMessage className="shad-form_message" />
                                </FormItem>
                            )}
                        />
                        {
                            wantToPost && (
                                <div className="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        checked={wantToPost}
                                        onChange={(e) => setWantToPost(e.target.checked)}
                                    />
                                    <label className="text-sm">Creat a post with new profile photo</label>
                                </div>
                            )
                        }

                        <FormField
                            control={form.control}
                            name="name"
                            render={({ field }) => (
                                <FormItem>
                                    <FormLabel className="shad-form_label">Name</FormLabel>
                                    <FormControl>
                                        <Input type="text" className="shad-input" {...field} />
                                    </FormControl>
                                    <FormMessage />
                                </FormItem>
                            )}
                        />

                        <FormField
                            control={form.control}
                            name="username"
                            render={({ field }) => (
                                <FormItem>
                                    <FormLabel className="shad-form_label">Username</FormLabel>
                                    <FormControl>
                                        <Input
                                            type="text"
                                            className="shad-input"
                                            {...field}
                                        />
                                    </FormControl>
                                    <FormMessage />
                                </FormItem>
                            )}
                        />

                        <div className="flex items-center gap-4">
                            <FormField
                                control={form.control}
                                name="email"
                                render={({ field }) => (
                                    <FormItem className="flex-1">
                                        <FormLabel className="shad-form_label">Email</FormLabel>
                                        <FormControl>
                                            <Input
                                                type="text"
                                                className="shad-input"
                                                {...field}
                                                disabled
                                            />
                                        </FormControl>
                                        <FormMessage />
                                    </FormItem>
                                )}
                            />

                            <div className="mt-6">
                                <ChangePasswordDialog />
                            </div>
                        </div>

                        <FormField
                            control={form.control}
                            name="bio"
                            render={({ field }) => (
                                <FormItem>
                                    <FormLabel className="shad-form_label">Bio</FormLabel>
                                    <FormControl>
                                        <Textarea
                                            className="shad-textarea custom-scrollbar"
                                            {...field}
                                        />
                                    </FormControl>
                                    <FormMessage className="shad-form_message" />
                                </FormItem>
                            )}
                        />

                        <div className="flex gap-4 items-center justify-end">
                            <Button
                                type="button"
                                className="shad-button_dark_4"
                                onClick={() => navigate(-1)}
                            >
                                Cancel
                            </Button>
                            <Button
                                type="submit"
                                className="shad-button_primary whitespace-nowrap"
                                disabled={isLoadingUpdate}
                            >
                                {isLoadingUpdate && <Loader />}
                                Update Profile
                            </Button>
                        </div>
                    </form>
                </Form>
            </div>
        </div>
    );
};

export default UpdateProfile;

```

### killigraphy_back_end\src\app.ts
```ts
import express, { Response, NextFunction, Request } from 'express';
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import http from "http";

import authRoutes from './routes/auth';
import postsRouter from './routes/posts';
import savesRouter from './routes/saves';
import commentRouter from './routes/comments';
import usersRouter from './routes/users';
import chatsRouter from './routes/chats';
import messageRouter from './routes/messages';
import { initSocket } from "./socket";
import cron from 'node-cron';
import { refreshSuggestionsForAllUsers } from './cron/refreshSuggestions';

const allowedOrigins = ['http://localhost', 'http://localhost:80', 'http://localhost:5173'];
dotenv.config();

const app = express();
const PORT = process.env.PORT || 8085;
const server = http.createServer(app);

// Initialize socket.io
const io = initSocket(server);
app.set("io", io);

// Middleware
app.use(cors({
    origin: function (origin, callback) {
        if (!origin || allowedOrigins.includes(origin)) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    credentials: true
}));
app.use(express.json());
app.use(cookieParser());

cron.schedule('*/10 * * * *', () => {
    console.log("Running suggestion refresh job...");
    refreshSuggestionsForAllUsers().catch(console.error);
});

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/posts', postsRouter);
app.use('/api/saves', savesRouter);
app.use('/api/comments', commentRouter);
app.use('/api/users', usersRouter);
app.use('/api/chats', chatsRouter);
app.use('/api/messages', messageRouter);

// MongoDB connect
mongoose.connect(process.env.MONGODB_URI!)
    .then(() => {
        console.log('MongoDB connected');

        // Only call server.listen once here
        server.listen(PORT, () => {
            console.log(`Server running at http://localhost:${PORT}`);
        });
    })
    .catch((err) => {
        console.error('MongoDB connection error:', err);
    });

app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
    console.error('Unhandled error:', err.stack);
    res.status(500).json({ message: 'Internal Server Error', error: err.message });
});
```

### killigraphy_back_end\src\socket.ts
```ts
import { Server, Socket } from "socket.io";

interface SendMessageData {
    chatId: string;
    message: string;
}

interface SeenMessageData {
    chatId: string;
    userId: string;
    messageId: string;
}

interface CallData {
    targetId: string;
    offer?: any;
    answer?: any;
    from?: string;
    candidate?: any;
}

export const initSocket = (server: any) => {
    const io = new Server(server, {
        cors: {
            origin: "*",
            methods: ["GET", "POST"],
        },
    });

    io.on("connection", (socket: Socket) => {
        console.log("Socket connected:", socket.id);

        socket.on("join_chat", (chatId: string) => {
            socket.join(chatId);
        });

        socket.on("leave_chat", (chatId: string) => {
            socket.leave(chatId);
        });

        socket.on("send_message", (messageData: SendMessageData) => {
            const { chatId, message } = messageData;
            io.to(chatId).emit("new_message", message);
        });

        socket.on("seen_message", ({ chatId, userId, messageId }: SeenMessageData) => {
            io.to(chatId).emit("message_seen", { chatId, userId, messageId });
        });

        socket.on("typing", ({ chatId, userId }: { chatId: string; userId: string }) => {
            socket.to(chatId).emit("user_typing", { userId });
        });

        socket.on("stop_typing", ({ chatId, userId }: { chatId: string; userId: string }) => {
            socket.to(chatId).emit("user_stop_typing", { userId });
        });

        socket.on("call_user", ({ targetId, offer, from }: CallData) => {
            io.to(targetId).emit("incoming_call", { from, offer });
        });

        socket.on("answer_call", ({ targetId, answer }: CallData) => {
            io.to(targetId).emit("call_answered", { answer });
        });

        socket.on("ice_candidate", ({ targetId, candidate }: CallData) => {
            io.to(targetId).emit("ice_candidate", { candidate });
        });

        socket.on("end_call", ({ targetId }: CallData) => {
            io.to(targetId).emit("call_ended");
        });

        socket.on("disconnect", () => {
            console.log("Socket disconnected:", socket.id);
        });
    });

    return io;
};

```

### killigraphy_back_end\src\config\imagekit.ts
```ts
import ImageKit from "imagekit";

const imagekit = new ImageKit({
    publicKey: process.env.IMAGEKIT_PUBLIC_KEY || "",
    privateKey: process.env.IMAGEKIT_PRIVATE_KEY || "",
    urlEndpoint: process.env.IMAGEKIT_URL_ENDPOINT || "",
});

export default imagekit;

```

### killigraphy_back_end\src\config\redis.ts
```ts
// src/config/RedisClient.ts
import Redis from 'ioredis';

class RedisClient {
    private static instance: Redis;

    private constructor() { }

    public static getInstance() {
        if (!RedisClient.instance) {
            RedisClient.instance = new Redis({
                host: process.env.REDIS_HOST || 'localhost',
                port: parseInt(process.env.REDIS_PORT || '6379', 10),
            });

            RedisClient.instance.on('error', (err) => {
                console.error('Redis connection error:', err);
            });

            RedisClient.instance.on('connect', () => {
                console.log('Redis connected!');
            });
        }
        return RedisClient.instance;
    }
}

export default RedisClient;

```

### killigraphy_back_end\src\controllers\auth.controller.ts
```ts
import { Request, Response } from 'express';
import { AuthenticatedRequest } from '../types/index';
import { AuthService } from '../services/auth.service';
import { UserFactory } from '../factories/UserFactory/UserFactory';
import RedisClient from '../config/redis';
import { RedisAdapter } from '../utils/adapters/RedisAdapter/RedisAdapter';

const userFactory = new UserFactory();
const redisAdapter = new RedisAdapter();

const authService = new AuthService(userFactory, redisAdapter);

export const register = async (req: Request, res: Response) => {
    try {
        const user = await authService.registerUser(req.body);
        res.status(201).json(user);
    } catch (err) {
        console.error('Register error:', err);
        res.status(500).json({ message: 'Server error' });
    }
};

export const login = async (req: Request, res: Response) => {
    try {
        const { user, token } = await authService.loginUser(req.body);
        res.cookie('token', token, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'lax',
            maxAge: 7 * 24 * 60 * 60 * 1000,
        });
        res.json({ user });
    } catch (err) {
        console.error('Login error:', err);
        res.status(500).json({ message: 'Server error' });
    }
};

export const getMe = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const user = await authService.getCurrentUser(req.userId!);
        res.json(user);
    } catch (err) {
        res.status(500).json({ message: 'Server error' });
    }
};

export const logout = (_req: Request, res: Response) => {
    res.clearCookie('token', {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
    });
    res.json({ message: 'Logged out successfully' });
};

export const requestOtp = async (req: Request, res: Response) => {
    try {
        await authService.sendOtp(req.body.email);
        res.json({ message: 'OTP sent' });
    } catch (err) {
        res.status(500).json({ message: 'Failed to send OTP' });
    }
};

export const verifyOtp = async (req: Request, res: Response) => {
    try {
        const result = await authService.verifyOtp(req.body.email, req.body.otp);
        res.json(result);
    } catch (err) {
        res.status(401).json({ message: 'Invalid or expired OTP' });
    }
};

```

### killigraphy_back_end\src\controllers\comment.controller.ts
```ts
import { Request, Response } from "express";
import { AuthenticatedRequest } from '../types/index';
import { CommentService } from "../services/comment.service";
import { CommentFactory } from "../factories/CommentFactory/CommentFactory";

const commentService = new CommentService(new CommentFactory());


export const createComment = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const { content, postId, parentId } = req.body;
        const userId = req.userId!;

        const comment = await commentService.addComment(content, postId, userId, parentId);
        res.status(201).json(comment);
    } catch (err: any) {
        res.status(500).json({ message: err.message || "Failed to create comment" });
    }
};

export const getComments = async (req: Request, res: Response) => {
    try {
        const comments = await commentService.getPostComments(req.params.postId);
        res.json(comments);
    } catch (err: any) {
        res.status(500).json({ message: err.message || "Failed to fetch comments" });
    }
};

export const deleteComment = async (req: AuthenticatedRequest, res: Response) => {
    try {
        await commentService.deleteComment(req.params.id, req.userId!);
        res.json({ message: "Comment deleted" });
    } catch (err: any) {
        if (err.message === "Comment not found") {
            res.status(404).json({ message: err.message });
        } else if (err.message === "Unauthorized") {
            res.status(403).json({ message: err.message });
        } else {
            res.status(500).json({ message: err.message || "Failed to delete comment" });
        }
    }
};

```

### killigraphy_back_end\src\controllers\post.controller.ts
```ts
import e, { Request, Response } from "express";
import { AuthenticatedRequest } from '../types/index';
import { PostService } from "../services/post.service";
import { PostFactory } from "../factories/PostFactory/PostFactory";
import { FeedService } from "../services/feed.service";
import { PersonalizedFeedStrategy } from "../strategies/FeedStrategy/PersonalizedFeedStrategy";
import { RedisAdapter } from "../utils/adapters/RedisAdapter/RedisAdapter";
import { ImageKitAdapter } from "../utils/adapters/ImageKitAdapter/ImageKitAdapter";
import { PostUpdateStrategy } from "../strategies/UpdateStrategy/PostUpdateStrategy";
import { imageKitAdapterSingleton } from "../utils/singleton/ImageKitAdapterSingleton";

const postUpdateStrategy = new PostUpdateStrategy(imageKitAdapterSingleton);

const postService = new PostService(
    new PostFactory(),
    new FeedService(new PersonalizedFeedStrategy()),
    new ImageKitAdapter(),
    new RedisAdapter(),
    postUpdateStrategy
);

export const createPost = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const { caption, location, tags } = req.body;
        const file = req.file;
        const userId = req.userId!;

        if (!file) {
            return res.status(400).json({ message: "Image file is required" });
        }

        const result = await postService.createPost({ caption, location, tags, file, userId });
        res.status(201).json(result);
    } catch (err) {
        console.error("Create post error:", err);
        res.status(500).json({ message: "Internal server error" });
    }
};

export const updatePost = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const { caption, location, tags } = req.body;

        const image = req.file;

        const updated = await postService.updatePost({
            id: req.params.id,
            caption,
            location,
            tags,
            image: image && image.buffer ? image : undefined,
            userId: req.userId!,
        });

        res.json(updated);
    } catch (err: any) {
        console.error("Update post error:", err);
        res.status(500).json({ message: "Internal server error" });
    }
};

export const getPostsByUserId = async (req: Request, res: Response) => {
    try {
        const posts = await postService.getPostsByUserId(req.params.userId);
        if (!posts.length) return res.status(404).json({ message: "No posts found" });
        res.json(posts);
    } catch (err) {
        console.error("Get user posts error:", err);
        res.status(500).json({ message: "Internal server error" });
    }
};

export const handleDeletePost = async (req: Request, res: Response) => {
    try {
        await postService.deletePostWithImage(req.params.id);
        res.json({ message: "Post deleted successfully" });
    } catch (err) {
        res.status(404).json({ message: err instanceof Error ? err.message : "Post not found" });
    }
};

export const handleGetMetaTrend = async (req: Request, res: Response) => {
    try {
        const page = parseInt(req.query.page as string) || 1;
        const limit = parseInt(req.query.limit as string) || 10;
        const data = await postService.getMetaTrend(page, limit);
        res.json(data);
    } catch (err) {
        res.status(500).json({ message: "Failed to fetch meta", error: err });
    }
};

export const handleSearchPosts = async (req: Request, res: Response) => {
    try {
        const results = await postService.searchPostsService(req.query);
        res.json(results);
    } catch (err) {
        res.status(500).json({ message: "Search failed", error: err });
    }
};

export const handleGetPostById = async (req: Request, res: Response) => {
    try {
        const post = await postService.getPostById(req.params.id);
        if (!post) return res.status(404).json({ message: "Post not found" });
        res.json(post);
    } catch (err) {
        console.error("Get post by ID error:", err);
        res.status(500).json({ message: "Internal server error" });
    }
}

export const handleGetPostsByList = async (req: Request, res: Response) => {
    try {
        let { postIds } = req.query;

        if (!postIds) {
            return res.status(400).json({ message: "Missing post IDs" });
        }

        // Nếu postIds là string thì split nó ra array
        if (typeof postIds === "string") {
            postIds = postIds.split(",");
        }

        if (!Array.isArray(postIds) || postIds.length === 0) {
            return res.status(400).json({ message: "Invalid post IDs" });
        }

        const posts = await postService.getPostsByList(postIds as string[]);
        res.json(posts);
    } catch (err) {
        console.error("Get posts by list error:", err);
        res.status(500).json({ message: "Internal server error" });
    }
};

export const handleToggleLikePost = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const postId = req.params.id;
        const userId = req.userId!;

        if (!postId || !userId) {
            return res.status(400).json({ message: "Post ID and User ID are required" });
        }

        const updatedPost = await postService.toggleLikePost({ postId, userId });
        res.json(updatedPost);
    } catch (err) {
        console.error("Toggle like post error:", err);
        res.status(500).json({ message: "Internal server error" });
    }
}

export const handGetPersonalizedFeed = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const userId = req.userId!;
        const page = Number(req.query.page) || 1;
        const limit = Number(req.query.limit) || 12;

        const result = await postService.getPersonalizedFeed(userId, page, limit);
        res.status(200).json(result);
    } catch (err) {
        console.error("Get personalized feed error:", err);
        res.status(500).json({ message: "Internal server error" });
    }
};

export const handleGetPaginatedPosts = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const page = Math.max(Number(req.query.page) || 1, 1);
        const limit = Math.max(Number(req.query.limit) || 12, 1);

        if (page < 1 || limit < 1) {
            return res.status(400).json({ message: "Invalid page or limit" });
        }

        const posts = await postService.getPaginatedPosts(page, limit);
        res.status(200).json(posts);
    } catch (err) {
        console.error("Get paginated posts error:", err);
        res.status(500).json({ message: "Internal server error" });
    }
};

```

### killigraphy_back_end\src\controllers\save.controller.ts
```ts
import { Request, Response } from 'express';
import { AuthenticatedRequest } from '../types/index';
import { SaveService } from '../services/save.service';
import { SaveFactory } from '../factories/SaveFactory/SaveFactory';

const saveService = new SaveService(new SaveFactory());

export const savePost = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const result = await saveService.savePost(req.userId!, req.body.postId);
        res.status(201).json(result);
    } catch (err: any) {
        if (err.message === 'Already saved') {
            res.status(409).json({ message: err.message });
        } else {
            res.status(500).json({ message: 'Internal server error' });
        }
    }
};

export const unsavePost = async (req: AuthenticatedRequest, res: Response) => {
    try {
        await saveService.unsavePost(req.userId!, req.params.postId);
        res.json({ message: 'Unsave success' });
    } catch (err: any) {
        if (err.message === 'Save not found') {
            res.status(404).json({ message: err.message });
        } else {
            res.status(500).json({ message: 'Internal server error' });
        }
    }
};

export const getSavedPosts = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const posts = await saveService.getSavedPosts(req.userId!);``
        if (!posts.length) {
            return res.status(404).json({ message: 'No saved posts found' });
        }
        res.json(posts);
    } catch (err) {
        res.status(500).json({ message: 'Internal server error' });
    }
};

```

### killigraphy_back_end\src\controllers\user.controller.ts
```ts
import { Request, Response } from 'express';
import { AuthenticatedRequest } from '../types/index';
import mongoose from 'mongoose';
import { UserService } from '../services/user.service';
import { ImageKitAdapter } from '../utils/adapters/ImageKitAdapter/ImageKitAdapter';
import { RedisAdapter } from '../utils/adapters/RedisAdapter/RedisAdapter';
import { UserUpdateStrategy } from '../strategies/UpdateStrategy/UserUpdateStrategy';
import { imageKitAdapterSingleton } from '../utils/singleton/ImageKitAdapterSingleton';

const userService = new UserService(
    new UserUpdateStrategy(imageKitAdapterSingleton),
    new ImageKitAdapter(),
    new RedisAdapter(),
);

export const getPaginatedUsers = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const page = Number(req.query.page) || 1;
        const limit = Number(req.query.limit) || 10;
        const currentUserId = req.userId!;

        const users = await userService.getPaginatedUsersWithFallback(currentUserId, page, limit);
        res.status(200).json(users);
    } catch (error) {
        console.error('Error fetching paginated users with fallback:', error);
        res.status(500).json({ message: 'Internal server error' });
    }
};

export const getUser = async (req: Request, res: Response) => {
    try {
        const userId = req.params.id;
        const user = await userService.getUserById(userId);
        res.status(200).json(user);
    } catch (error) {
        console.error('Error fetching user:', error);
        res.status(404).json({ message: 'User not found' });
    }
};

export const getFollowers = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const followers = await userService.getFollowersWithFollowStatus(req.params.id, req.userId!);
        res.status(200).json(followers);
    } catch (err) {
        console.error('Get followers error:', err);
        res.status(500).json({ message: 'Internal server error' });
    }
};

export const getFollowing = async (req: Request, res: Response) => {
    try {
        const following = await userService.getFollowing(req.params.id);
        res.status(200).json(following);
    } catch (err) {
        console.error('Get following error:', err);
        res.status(500).json({ message: 'Internal server error' });
    }
};

export const checkIsFollowing = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const isFollowing = await userService.checkIsFollowing(req.userId!, req.params.id);
        res.status(200).json({ isFollowing });
    } catch (err) {
        console.error('Check isFollowing error:', err);
        res.status(500).json({ message: 'Internal server error' });
    }
};

export const toggleFollow = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const result = await userService.toggleFollowUser(req.userId!, req.params.id);
        res.status(200).json(result);
    } catch (error) {
        console.error('Follow/unfollow error:', error);
        res.status(500).json({ message: 'Internal server error' });
    }
};

export const updateUser = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const userId = req.params.id;
        const { username, name, bio } = req.body;
        const file = req.file;

        if (!mongoose.Types.ObjectId.isValid(userId)) {
            return res.status(400).json({ message: "Invalid user ID" });
        }

        const updatedUser = await userService.updateUserProfile({
            userId,
            username,
            name,
            bio,
            file: file && file.buffer ? file : undefined,
        });

        res.status(200).json(updatedUser);
    } catch (err) {
        console.error("Update user error:", err);
        res.status(500).json({ message: 'Internal server error' });
    }
};

export const updatePassword = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const userId = req.params.id;
        const { oldPassword, newPassword } = req.body;

        if (!mongoose.Types.ObjectId.isValid(userId)) {
            return res.status(400).json({ message: "Invalid user ID" });
        }

        const result = await userService.updateUserPassword(userId, oldPassword, newPassword);
        res.status(200).json(result);
    } catch (err: any) {
        console.error("Update password error:", err);
        if (err.message === "User not found" || err.message === "Old password is incorrect") {
            res.status(400).json({ message: err.message });
        } else {
            res.status(500).json({ message: "Internal server error" });
        }
    }
};

export const getSuggestions = async (req: AuthenticatedRequest, res: Response) => {
    try {
        const userId = req.params.id;
        const page = Number(req.query.page) || 1;
        const limit = Number(req.query.limit) || 10;

        if (!mongoose.Types.ObjectId.isValid(userId)) {
            return res.status(400).json({ message: "Invalid user ID" });
        }

        const suggestions = await userService.getUserSuggestions(userId, page, limit);
        res.status(200).json(suggestions);
    } catch (err) {
        console.error("Error getting suggestions:", err);
        res.status(500).json({ message: "Internal server error" });
    }
};
```

### killigraphy_back_end\src\cron\refreshSuggestions.ts
```ts
import User from '../models/Users';
import Posts from '../models/Posts';
import RedisClient from '../config/redis';
import { redisAdapterSingleton } from '../utils/singleton/RedisAdapterSingleton';

export const refreshSuggestionsForAllUsers = async () => {
    try {
        const users = await User.find({}, '_id following');

        for (const user of users) {
            const userId = user._id.toString();
            const followingIds = user.following.map(id => id.toString());
            const excludedIds = [userId, ...followingIds];

            const mutualMap = new Map<string, number>();

            const followedUsers = await User.find({ _id: { $in: followingIds } }).select('following');
            for (const u of followedUsers) {
                for (const followee of u.following) {
                    const strId = followee.toString();
                    if (!excludedIds.includes(strId)) {
                        mutualMap.set(strId, (mutualMap.get(strId) || 0) + 1);
                    }
                }
            }

            const userPosts = await Posts.find({ $or: [{ author: userId }, { likes: userId }] }).select('tags');
            const tagCount: Record<string, number> = {};
            userPosts.forEach(p => {
                if (p.tags) {
                    p.tags.forEach(tag => {
                        tagCount[tag] = (tagCount[tag] || 0) + 1;
                    });
                }
            });

            const allOtherUsers = await User.find({ _id: { $nin: excludedIds } }).select('_id');
            const userIdList = allOtherUsers.map(u => u._id.toString());

            const zsetKey = `suggestions:zset:${userId}`;
            await redisAdapterSingleton.del(zsetKey); // clear old suggestions

            for (const otherUserId of userIdList) {
                const posts = await Posts.find({ author: otherUserId }).select('tags');
                let tagScore = 0;
                posts.forEach(post => {
                    if (post.tags) {
                        post.tags.forEach(tag => {
                            tagScore += tagCount[tag] || 0;
                        });
                    }
                });

                const mutualScore = mutualMap.get(otherUserId) || 0;
                const finalScore = mutualScore * 10 + tagScore;

                if (finalScore > 0) {
                    await redisAdapterSingleton.zAdd(zsetKey, finalScore, otherUserId);
                }
            }

            await redisAdapterSingleton.expire(zsetKey, 300); // cache ZSET 5 phút
            console.log(`Refreshed suggestions for user: ${userId}`);
        }
    } catch (err) {
        console.error("Error refreshing suggestions:", err);
    }
};

```

### killigraphy_back_end\src\enum\chat.ts
```ts
export enum ChatType {
    GROUP = "group",
    PRIVATE = "private",
}
```

### killigraphy_back_end\src\enum\chatHistory.ts
```ts
export enum ChatAction {
    MESSAGE = "message",
    JOINED = "joined",
    LEFT = "left",
    KICKED = "kicked",
    ADDED = "added",
    RENAMED = "renamed",
    DELETED = "deleted",
    PROMOTED = "promoted",
    DEMOTED = "demoted",
    BLOCKED = "blocked",
    UNBLOCKED = "unblocked",
    MUTE = "mute",
    UNMUTE = "unmute",
    PINNED = "pinned",
    UNPINNED = "unpinned",
}
```

### killigraphy_back_end\src\enum\message.ts
```ts
// src/constants/message.ts

export enum MessageType {
    TEXT = "text",
    IMAGE = "image",
    VOICE = "voice",
}

export enum MessageStatus {
    SEEN = "seen",
    UNSEEN = "unseen",
    DISCARDED = "discard",
}

```

### killigraphy_back_end\src\factories\CommentFactory\CommentFactory.ts
```ts
// src/factories/CommentFactory.ts
import { ICommentFactory } from './ICommentFactory';
import { CreateCommentInput, CommentDocument } from '../../types/index';
import mongoose from 'mongoose';

export class CommentFactory implements ICommentFactory {
    create(input: CreateCommentInput): Partial<CommentDocument> {
        return {
            content: input.content,
            post: new mongoose.Types.ObjectId(input.postId),
            user: new mongoose.Types.ObjectId(input.userId),
            parent: input.parentId ? new mongoose.Types.ObjectId(input.parentId) : null,
        };
    }
}

```

### killigraphy_back_end\src\factories\CommentFactory\ICommentFactory.ts
```ts
// src/factories/ICommentFactory.ts
import { CreateCommentInput, CommentDocument } from "../../types/index";

export interface ICommentFactory {
    create(input: CreateCommentInput): Partial<CommentDocument>;
}

```

### killigraphy_back_end\src\factories\PostFactory\IPostFactory.ts
```ts
// src/factories/IPostFactory.ts

import { CreatePostResponse, PostDocument } from "../../types";

export interface IPostFactory {
    create(input: CreatePostResponse): Partial<PostDocument>;
}

```

### killigraphy_back_end\src\factories\PostFactory\PostFactory.ts
```ts
// src/factories/PostFactory.ts
import { CreatePostResponse, PostDocument } from '../../types';
import { IPostFactory } from './IPostFactory';
import mongoose from 'mongoose';

export class PostFactory implements IPostFactory {
    create(input: CreatePostResponse): Partial<PostDocument> {
        return {
            creator: new mongoose.Types.ObjectId(input.creator),
            caption: input.caption,
            location: input.location || '',
            tags: input.tags || [],
            imageId: input.imageId || '',
            imageURL: input.imageURL || '',
        };
    }
}

```

### killigraphy_back_end\src\factories\SaveFactory\ISaveFactory.ts
```ts
// src/factories/SaveFactory/ISaveFactory.ts
import { CreateSaveInput, SaveDocument } from "../../types";

export interface ISaveFactory {
    create(input: CreateSaveInput): Partial<SaveDocument>;
}

```

### killigraphy_back_end\src\factories\SaveFactory\SaveFactory.ts
```ts
// src/factories/SaveFactory.ts
import mongoose from "mongoose";
import { CreateSaveInput, SaveDocument } from "../../types";
import { ISaveFactory } from "./ISaveFactory";

export class SaveFactory implements ISaveFactory {
    create(input: CreateSaveInput): Partial<SaveDocument> {
        return {
            user: new mongoose.Types.ObjectId(input.userId),
            post: new mongoose.Types.ObjectId(input.postId),
        };
    }
}
```

### killigraphy_back_end\src\factories\UserFactory\IUserFactory.ts
```ts
// src/factories/IUserFactory.ts
import { RegisterUserInput, UserDocument } from '../../types/index';

export interface IUserFactory {
    create(input: RegisterUserInput): Promise<Partial<UserDocument>>;
}
```

### killigraphy_back_end\src\factories\UserFactory\UserFactory.ts
```ts
// src/factories/UserFactory.ts
import { IUserFactory } from './IUserFactory';
import { RegisterUserInput, UserDocument } from '../../types/index';
import crypto from 'crypto';
import { hashPassword } from '../../utils/hashPassword';

export class UserFactory implements IUserFactory {
    async create(input: RegisterUserInput): Promise<Partial<UserDocument>> {
        const hashedPassword = await hashPassword(input.password);
        return {
            name: input.name,
            username: input.username,
            email: input.email,
            password: hashedPassword,
            imageUrl: 'https://ik.imagekit.io/killigraphy/profile-placeholder.svg',
            accountId: crypto.randomUUID(),
            followers: [],
            following: [],
            likedPosts: [],
        };
    }
}

```

### killigraphy_back_end\src\middleware\autoMarkSeen.ts
```ts
// src/middlewares/autoMarkSeen.ts

import { Request, Response, NextFunction } from "express";
import Message from "../models/Message";
import { MessageStatus } from "../enum/message";

interface AuthenticatedRequest extends Request {
    userId?: string;
}

export const autoMarkSeen = async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    try {
        const { chatId } = req.params;
        const userId = req.userId;

        await Message.updateMany(
            {
                chat: chatId,
                receiver: userId,
                status: MessageStatus.UNSEEN,
            },
            {
                $set: {
                    status: MessageStatus.SEEN,
                    seenAt: new Date(),
                },
            }
        );

        req.app.get("io")?.emit("message_seen", { chatId, userId });

        next();
    } catch (err) {
        console.error("Error in autoMarkSeen middleware", err);
        next();
    }
};

```

### killigraphy_back_end\src\middleware\requireAuth.ts
```ts
import { Request, Response, NextFunction } from 'express';
import { jwtVerify } from 'jose';

interface AuthenticatedRequest extends Request {
    userId?: string;
}

export const requireAuth = async (
    req: AuthenticatedRequest,
    res: Response,
    next: NextFunction
) => {
    try {
        // Lấy token từ cookie 'token'
        const token = req.cookies?.token;
        if (!token) throw new Error('No token');

        const secret = process.env.JWT_SECRET;
        if (!secret) throw new Error('Missing JWT_SECRET');

        const { payload } = await jwtVerify(token, new TextEncoder().encode(secret));
        req.userId = payload.id as string;

        next();
    } catch (err) {
        console.error('Auth middleware error:', err);
        return res.status(401).json({ message: 'Unauthorized' });
    }
};

```

### killigraphy_back_end\src\middleware\upload.ts
```ts
import multer from "multer";

export const upload = multer({
    storage: multer.memoryStorage(), // dùng memory
});

```

### killigraphy_back_end\src\models\Chat.ts
```ts
// src/models/Chat.ts
import mongoose, { Schema, Document } from "mongoose";

export interface IChat extends Document {
    isGroup: boolean;
    members: mongoose.Types.ObjectId[];
    lastMessage?: mongoose.Types.ObjectId;
    name?: string;
    avatar?: string;
    admins?: mongoose.Types.ObjectId[];
}

const chatSchema = new Schema<IChat>({
    isGroup: { type: Boolean, required: true },
    members: [{ type: Schema.Types.ObjectId, ref: "User" }],
    lastMessage: { type: Schema.Types.ObjectId, ref: "Message" },
    name: {
        type: String,
        required: function (this: IChat) {
            return this.isGroup;
        }
    },
    avatar: String,
    admins: [{ type: Schema.Types.ObjectId, ref: "User" }],
}, {
    timestamps: true,
});

const Chat = mongoose.model<IChat>("Chat", chatSchema);
export default Chat;
```

### killigraphy_back_end\src\models\ChatHistory.ts
```ts
// src/models/ChatHistory.ts
import mongoose from "mongoose";
import { ChatAction } from "../enum/chatHistory";

const chatHistorySchema = new mongoose.Schema({
    chat: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Chat",
        required: true,
    },
    action: {
        type: String,
        enum: Object.values(ChatAction),
        default: ChatAction.MESSAGE,
        required: true,
    },
    actor: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
    },
    targetUser: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
    },
    messageId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Message",
    },
    message: {
        type: String,
    },
}, {
    timestamps: true,
});

export default mongoose.model("ChatHistory", chatHistorySchema);

```

### killigraphy_back_end\src\models\Comment.ts
```ts
// models/Comment.ts
import mongoose, { Model } from 'mongoose';
import { CommentDocument } from '../types';

const commentSchema = new mongoose.Schema<CommentDocument>({
    content: { type: String, required: true },
    post: { type: mongoose.Schema.Types.ObjectId, ref: 'Post', required: true },
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    parent: { type: mongoose.Schema.Types.ObjectId, ref: 'Comment', default: null },
}, {
    timestamps: true
});

const Comment: Model<CommentDocument> = mongoose.model<CommentDocument>('Comment', commentSchema);
export default Comment;
```

### killigraphy_back_end\src\models\Message.ts
```ts
// src/models/Message.ts
import mongoose from "mongoose";
import { MessageStatus, MessageType } from "../enum/message";

const messageSchema = new mongoose.Schema({
    chat: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Chat",
        required: true,
    },
    sender: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
        required: true,
    },
    receiver: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
    },

    // Reply
    replyTo: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Message",
    },
    replyToMessage: String,
    replyToSender: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
    },
    replyToReceiver: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
    },
    replyToType: {
        type: String,
        enum: Object.values(MessageType),
    },
    replyToStatus: {
        type: String,
        enum: Object.values(MessageStatus),
    },

    // Main message data
    type: {
        type: String,
        enum: Object.values(MessageType),
        default: MessageType.TEXT,
    },
    status: {
        type: String,
        enum: Object.values(MessageStatus),
        default: MessageStatus.UNSEEN,
    },
    content: {
        type: String, // text content or file URL (for image/voice)
        required: true,
    },
    imageId: String, // if type = image
    voiceId: String, // if type = voice

    // Timestamps for status
    seenAt: Date,
    discardedAt: Date,
    deletedAt: Date, // optional: if user deletes message for self
}, {
    timestamps: true,
});

export default mongoose.model("Message", messageSchema);

```

### killigraphy_back_end\src\models\Posts.ts
```ts
// src/models/Posts.ts
import mongoose, { Model } from 'mongoose';
import { PostDocument } from '../types';

const postSchema = new mongoose.Schema<PostDocument>({
    creator: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },

    caption: { type: String },
    tags: [{ type: String }],
    imageURL: { type: String, required: true },
    imageId: { type: String, required: true },
    location: { type: String },

    likes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
}, {
    timestamps: true
});

const Post: Model<PostDocument> = mongoose.model<PostDocument>('Post', postSchema);
export default Post;

```

### killigraphy_back_end\src\models\Saves.ts
```ts
// src/models/Saves.ts
import mongoose, { Model } from 'mongoose';
import { SaveDocument } from '../types';

const saveSchema = new mongoose.Schema<SaveDocument>({
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    post: { type: mongoose.Schema.Types.ObjectId, ref: 'Post', required: true },
}, {
    timestamps: true
});

const Save: Model<SaveDocument> = mongoose.model<SaveDocument>('Save', saveSchema);
export default Save;

```

### killigraphy_back_end\src\models\Users.ts
```ts
// src/models/User.ts
import mongoose from 'mongoose';
import { UserDocument } from '../types';

const userSchema = new mongoose.Schema<UserDocument>({
    name: { type: String },
    username: { type: String },
    accountId: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    password: { type: String, required: true, select: false },
    bio: { type: String },
    imageId: { type: String },
    imageUrl: { type: String, required: true },
    likedPosts: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Post' }],

    followers: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
    following: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
}, {
    timestamps: true
});

const User = mongoose.model<UserDocument>('User', userSchema);
export default User;
```

### killigraphy_back_end\src\repositories\comment.repository.ts
```ts
import Comment from "../models/Comment";

export const createComment = async (data: any) => {
    return await Comment.create(data);
};

export const getCommentsByPostId = async (postId: string) => {
    return await Comment.find({ post: postId })
        .populate("user", "name imageUrl")
        .sort({ createdAt: 1 });
};

export const findCommentById = async (id: string) => {
    return await Comment.findById(id).populate("post", "creator");
};

export const deleteCommentById = async (id: string) => {
    return await Comment.findByIdAndDelete(id);
};

```

### killigraphy_back_end\src\repositories\post.repository.ts
```ts
import Posts from "../models/Posts";
import { CreatePostResponse, PostDocument } from "../types";

export const createPost = async (postData: Partial<PostDocument>) => {
    return await Posts.create(postData);
}

export const findPostById = async (postId: string) => {
    return await Posts.findById(postId).populate("creator");
};

export const savePost = async (post: any) => {
    return await post.save();
};

export const findPostsByUserId = async (userId: string) => {
    return await Posts.find({ creator: userId })
        .populate("creator")
        .sort({ createdAt: -1 });
};

export const deletePostById = (id: string) => Posts.findByIdAndDelete(id);

export const findAllTagsAndLocations = async () => {
    const posts = await Posts.find({}, "tags location -_id");

    const tagSet = new Set<string>();
    const locationSet = new Set<string>();

    posts.forEach((post) => {
        if (post.tags) {
            post.tags.forEach((tag) => tagSet.add(tag));
        }
        if (post.location) locationSet.add(post.location);
    });

    return {
        tags: Array.from(tagSet),
        locations: Array.from(locationSet),
    };
};

export const searchPosts = (filter: any, sort: any) =>
    Posts.find(filter).sort(sort).populate("creator");

export const findPostsByIds = async (postIds: string[]) => {
    return await Posts.find({ _id: { $in: postIds } })
        .populate("creator")
        .sort({ createdAt: -1 });
}

export const findAllPosts = async (skip: number, limit: number) => {
    return await Posts.find({})
        .populate("creator")
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit);
}
```

### killigraphy_back_end\src\repositories\save.repository.ts
```ts
import Saves from '../models/Saves';
import { SaveDocument } from '../types';

export const saveRepo = {
    findSave: async (userId: string, postId: string) =>
        await Saves.findOne({ user: userId, post: postId }),

    createSave: async (save: Partial<SaveDocument>) =>
        await Saves.create(save),

    deleteSave: async (userId: string, postId: string) =>
        await Saves.findOneAndDelete({ user: userId, post: postId }),

    getSavedPosts: async (userId: string) => {
        const saves = await Saves.find({ user: userId }).populate({
            path: 'post',
            populate: { path: 'creator' }
        });

        return saves.filter((s) => s.post != null).map((s) => s.post);
    }
};

```

### killigraphy_back_end\src\repositories\user.repository.ts
```ts
import Users from "../models/Users";

export const findUserById = (id: string) =>
    Users.findById(id).select('-password -__v -createdAt -updatedAt'
    );
export const findUsersByIds = (ids: string[]) =>
    Users.find({ _id: { $in: ids } }).select('-password -__v -createdAt -updatedAt'
    );
export const findUsersNotIn = (excludedIds: string[], skip: number, limit: number) =>
    Users.find({ _id: { $nin: excludedIds } })
        .select('-password -__v -createdAt -updatedAt')
        .skip(skip)
        .limit(limit);
export const saveUser = (user: any) => user.save();
export const findByEmail = (email: string) => {
    return Users.findOne({ email })
        .select('-password -__v -createdAt -updatedAt');
};
export const findByEmailWithPassword = (email: string) => {
    return Users.findOne({ email }).select('+password');
};
export const createUser = (data: any) => {
    return Users.create({
        ...data,
        imageUrl: 'https://ik.imagekit.io/killigraphy/profile-placeholder.svg',
    });
};
export const findUserByIdWithFollowers = (id: string) =>
    Users.findById(id).populate('followers', '-password -__v');

export const findUserByIdWithFollowing = (id: string) =>
    Users.findById(id).populate('following', '-password -__v');

export const findUserByIdWithPassword = (id: string) =>
    Users.findById(id).select('+password');
```

### killigraphy_back_end\src\routes\auth.ts
```ts
import express from 'express';
import { requireAuth } from '../middleware/requireAuth';
import * as authController from '../controllers/auth.controller';

const router = express.Router();

router.post('/register', authController.register);
router.post('/login', authController.login);
router.get('/me', requireAuth, authController.getMe);
router.post('/logout', authController.logout);
router.post('/request-otp', authController.requestOtp);
router.post('/verify-otp', authController.verifyOtp);

export default router;

```

### killigraphy_back_end\src\routes\chats.ts
```ts
import express, { Request, Response } from "express";
import mongoose from "mongoose";
import { requireAuth } from "../middleware/requireAuth";
import Chat from "../models/Chat";

const router = express.Router();

interface AuthenticatedRequest extends Request {
    userId?: string;
}

interface PopulatedUser {
    _id: string;
    name: string;
    username: string;
    imageUrl: string;
}

interface PopulatedChat {
    _id: string;
    isGroup: boolean;
    members: PopulatedUser[];
    lastMessage?: any;
    name?: string;
    avatar?: string;
    createdAt: Date;
    updatedAt: Date;
}

// GET /api/chats - Get all chats of the current user
router.get("/", requireAuth, async (req: AuthenticatedRequest, res: Response) => {
    try {
        const chats = await Chat.find({
            members: { $in: [req.userId] },
        })
            .populate<{ members: PopulatedUser[] }>("members", "name username imageUrl")
            .populate("lastMessage")
            .sort({ updatedAt: -1 });

        res.json(chats as unknown as PopulatedChat[]);
    } catch (err) {
        res.status(500).json({ message: "Failed to get chats", error: err });
    }
});

// GET /api/chats/:userId - Get chat between current user and target user
router.get("/:userId", requireAuth, async (req: AuthenticatedRequest, res: Response) => {
    try {
        const currentUserId = req.userId;
        const targetUserId = req.params.userId;

        if (!mongoose.Types.ObjectId.isValid(targetUserId)) {
            return res.status(400).json({ message: "Invalid userId" });
        }

        let chat = await Chat.findOne({
            isGroup: false,
            members: { $all: [currentUserId, targetUserId] },
        });

        if (!chat) {
            chat = await Chat.create({
                isGroup: false,
                members: [currentUserId, targetUserId],
            });
        }

        const populated = await chat.populate<{ members: PopulatedUser[] }>(
            "members",
            "name username imageUrl"
        );

        res.json(populated as unknown as PopulatedChat);
    } catch (err) {
        res.status(500).json({ message: "Failed to get/create private chat", error: err });
    }
});

export default router;

```

### killigraphy_back_end\src\routes\comments.ts
```ts
import express from "express";
import { requireAuth } from "../middleware/requireAuth";
import * as CommentController from "../controllers/comment.controller";

const router = express.Router();

router.post("/", requireAuth, CommentController.createComment);
router.get("/:postId", CommentController.getComments);
router.delete("/:id", requireAuth, CommentController.deleteComment);

export default router;

```

### killigraphy_back_end\src\routes\messages.ts
```ts
import express from 'express';
import { Request, Response } from 'express';
import { requireAuth } from '../middleware/requireAuth';
import Message from '../models/Message';
import Chat from '../models/Chat';

const router = express.Router();

interface AuthenticatedRequest extends Request {
    userId?: string;
}

router.get('/:id', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
    try {
        const chatId = req.params.id;
        const userId = req.userId as string;

        // Check current user is a member of the chat
        const chat = await Chat.findById(chatId);
        if (!chat) {
            return res.status(404).json({ error: "Chat not found" });
        }

        const isMember = chat.members.some((member: any) => member.toString() === userId.toString());
        if (!isMember) {
            return res.status(403).json({ error: "You are not a member of this chat" });
        }

        // Fetch messages for the chat
        const messages = await Message.find({ chatId })
            .sort({ createdAt: 1 }) // oldest → newest
            .populate("senderId", "username imageUrl"); // populate senderId with username and imageUrl
        res.status(200).json(messages);
    } catch (error) {
        console.error("getMessages error:", (error as Error).message);
        res.status(500).json({ error: "Internal server error" });
    }
})

export default router;

```

### killigraphy_back_end\src\routes\posts.ts
```ts
import express from "express";
import * as postController from "../controllers/post.controller";
import { requireAuth } from "../middleware/requireAuth";
import { upload } from "../middleware/upload";

const router = express.Router();

router.post("/", requireAuth, upload.single("image"), postController.createPost);
router.get("/", requireAuth, postController.handleGetPaginatedPosts);
router.get("/user/:userId", postController.getPostsByUserId);
router.get("/meta/trend", postController.handleGetMetaTrend);
router.get("/search", postController.handleSearchPosts);
router.get("/list", postController.handleGetPostsByList);
router.get("/feed/personalized", requireAuth, postController.handGetPersonalizedFeed);
router.patch("/:id", requireAuth, upload.single("image"), postController.updatePost);
router.delete("/:id", requireAuth, postController.handleDeletePost);
router.get("/:id", postController.handleGetPostById);
router.patch("/:id/like", requireAuth, postController.handleToggleLikePost);

export default router;

```

### killigraphy_back_end\src\routes\saves.ts
```ts
import express from 'express';
import { requireAuth } from '../middleware/requireAuth';
import {
    savePost,
    unsavePost,
    getSavedPosts,
} from '../controllers/save.controller';

const router = express.Router();

router.post('/', requireAuth, savePost);
router.delete('/:postId', requireAuth, unsavePost);
router.get('/', requireAuth, getSavedPosts);

export default router;

```

### killigraphy_back_end\src\routes\users.ts
```ts
import express from 'express';
import { requireAuth } from '../middleware/requireAuth';
import * as userController from '../controllers/user.controller';
import { upload } from '../middleware/upload'; // Assuming you have a middleware for file uploads

const router = express.Router();

// GET /users?page=1&limit=10
router.get('/', requireAuth, userController.getPaginatedUsers);

// GET /users/:id
router.get('/:id', userController.getUser);

// GET /users/:id/followers
router.get('/:id/followers', requireAuth, userController.getFollowers);

// GET /users/:id/following
router.get('/:id/following', userController.getFollowing);

// GET /users/:id/is-following
router.get('/:id/is-following', requireAuth, userController.checkIsFollowing);

// PATCH /users/:id/follow
router.patch('/:id/follow', requireAuth, userController.toggleFollow);

// PATCH /users/:id (update profile)
router.patch('/:id', requireAuth, upload.single('image'), userController.updateUser);

// PATCH /users/:id/password (update password)
router.patch('/:id/password', requireAuth, userController.updatePassword);

// GET /users/:id/suggestions
router.get('/:id/suggestions', requireAuth, userController.getSuggestions);

export default router;

```

### killigraphy_back_end\src\services\auth.service.ts
```ts
// src/services/AuthService.ts
import bcrypt from 'bcryptjs';
import { SignJWT } from 'jose';
import * as userRepo from '../repositories/user.repository';
import { sendEmail } from '../utils/sendEmail';
import { RegisterUserInput, LoginUserInput } from '../types/index';
import { IUserFactory } from '../factories/UserFactory/IUserFactory';
import { IRedisAdapter } from '../utils/adapters/RedisAdapter/IRedisAdapter';

export class AuthService {
    constructor(
        private userFactory: IUserFactory,
        private redisClient: IRedisAdapter
    ) { }

    async registerUser({ name, username, email, password }: RegisterUserInput) {
        const existing = await userRepo.findByEmail(email);
        if (existing) throw new Error('Email already exists');

        const userData = await this.userFactory.create({ name, username, email, password });
        return await userRepo.createUser(userData);
    }

    async loginUser({ email, password }: LoginUserInput) {
        const user = await userRepo.findByEmailWithPassword(email);
        if (!user || !(await bcrypt.compare(password, user.password))) {
            throw new Error('Invalid credentials');
        }

        const secret = process.env.JWT_SECRET!;
        const token = await new SignJWT({ id: user._id })
            .setProtectedHeader({ alg: 'HS256' })
            .setExpirationTime('7d')
            .sign(new TextEncoder().encode(secret));

        const { password: _, ...userData } = user.toObject();
        return { user: userData, token };
    }

    async getCurrentUser(userId: string) {
        const user = await userRepo.findUserById(userId);
        if (!user) throw new Error('User not found');
        const { password: _, ...data } = user.toObject();
        return data;
    }

    async sendOtp(email: string) {
        const otp = Math.floor(100000 + Math.random() * 900000).toString();
        await this.redisClient.setEx(`otp:${email}`, 300, otp);
        await sendEmail(email, 'Your OTP Code', `Your code is: ${otp}`);
    }

    async verifyOtp(email: string, otp: string) {
        const stored = await this.redisClient.get(`otp:${email}`);
        if (!stored || stored !== otp) {
            throw new Error('Invalid or expired OTP');
        }
        await this.redisClient.del(`otp:${email}`);
        return { verified: true };
    }
}

```

### killigraphy_back_end\src\services\comment.service.ts
```ts
// src/services/CommentService.ts
import { ICommentFactory } from '../factories/CommentFactory/ICommentFactory';
import * as commentRepo from '../repositories/comment.repository';

export class CommentService {
    constructor(private commentFactory: ICommentFactory) { }

    async addComment(content: string, postId: string, userId: string, parentId?: string) {
        if (!content || !postId) throw new Error('Missing required fields');

        const commentData = this.commentFactory.create({
            content,
            postId,
            userId,
            parentId,
        });

        const comment = await commentRepo.createComment(commentData);
        if (!comment) throw new Error('Failed to create comment');

        return await comment.populate('user', 'name imageUrl');
    }

    async getPostComments(postId: string) {
        return await commentRepo.getCommentsByPostId(postId);
    }

    async deleteComment(commentId: string, userId: string) {
        const comment = await commentRepo.findCommentById(commentId);
        if (!comment) throw new Error('Comment not found');

        const postCreatorId = (comment.post as any).creator;
        if (!postCreatorId.equals(userId)) {
            throw new Error('Unauthorized');
        }

        await commentRepo.deleteCommentById(commentId);
    }
}

```

### killigraphy_back_end\src\services\feed.service.ts
```ts
// src/services/FeedService.ts

import { IFeedStrategy } from "../strategies/FeedStrategy/IFeedStrategy";

export class FeedService {
    constructor(private strategy: IFeedStrategy) { }

    async getFeed(userId: string) {
        return await this.strategy.generateFeed(userId);
    }
}

```

### killigraphy_back_end\src\services\post.service.ts
```ts
// src/services/PostService.ts
import * as postRepo from "../repositories/post.repository";
import mongoose from "mongoose";
import * as userRepo from "../repositories/user.repository";
import { CreatePostInput, UpdatePostInput, LikePostInput } from "../types/index";
import { IPostFactory } from "../factories/PostFactory/IPostFactory";
import { FeedService } from "./feed.service";
import { IImageKitAdapter } from "../utils/adapters/ImageKitAdapter/IImageKitAdapter";
import { IRedisAdapter } from "../utils/adapters/RedisAdapter/IRedisAdapter";
import { IUpdateStrategy } from "../strategies/UpdateStrategy/IUpdateStrategy";

export class PostService {
    constructor(
        private postFactory: IPostFactory,
        private feedService: FeedService,
        private imageKitAdapter: IImageKitAdapter,
        private redisClient: IRedisAdapter,
        private postUpdateStrategy: IUpdateStrategy<UpdatePostInput, any>
    ) { }

    async createPost({ caption, location, tags, file, userId }: CreatePostInput) {
        if (!file) throw new Error("Image required");

        const result = await this.imageKitAdapter.upload(file);

        const postData = await this.postFactory.create({
            creator: userId,
            caption,
            location: location ?? "",
            tags: tags?.split(",").map(tag => tag.trim()) ?? [],
            imageId: result.fileId,
            imageURL: result.url,
        });

        return await postRepo.createPost(postData);
    }

    async updatePost(data: UpdatePostInput) {
        return await this.postUpdateStrategy.update(data);
    }

    async getPostsByUserId(userId: string) {
        return await postRepo.findPostsByUserId(userId);
    }

    async deletePostWithImage(postId: string) {
        const post = await postRepo.findPostById(postId);
        if (!post) throw new Error("Post not found");

        if (post.imageId) {
            try {
                await this.imageKitAdapter.delete(post.imageId);
            } catch (err) {
                console.error("Failed to delete image:", err);
            }
        }

        await postRepo.deletePostById(postId);
    }

    async getMetaTrend(page: number, limit: number) {
        const skip = (page - 1) * limit;

        const cached = await this.redisClient.get("post:meta");
        let tags: string[] = [];
        let locations: string[] = [];

        if (cached) {
            const parsed = JSON.parse(cached);
            tags = parsed.tags;
            locations = parsed.locations;
        } else {
            const result = await postRepo.findAllTagsAndLocations();
            tags = result.tags;
            locations = result.locations;

            await this.redisClient.setEx("post:meta", 300, JSON.stringify({ tags, locations }));
        }

        return {
            tags: tags.slice(skip, skip + limit),
            locations: locations.slice(skip, skip + limit),
            hasMore: skip + limit < tags.length || skip + limit < locations.length,
        };
    }

    async searchPostsService(query: any) {
        const { query: q, tags, location, sort } = query;

        const searchFilter: any = {};
        if (q) searchFilter.caption = { $regex: q, $options: "i" };
        if (tags) {
            const tagsArray = tags.split(",").map((tag: string) => tag.trim());
            searchFilter.tags = { $in: tagsArray };
        }
        if (location) {
            searchFilter.location = { $regex: location, $options: "i" };
        }

        let sortOption: { [key: string]: number } = { createdAt: -1 };
        if (sort === "popular") {
            sortOption = { likes: -1 };
        }

        return await postRepo.searchPosts(searchFilter, sortOption);
    }

    async getPostById(postId: string) {
        const post = await postRepo.findPostById(postId);
        if (!post) throw new Error("Post not found");

        await post.populate("creator", "name username imageUrl");
        return post;
    }

    async getPostsByList(postIds: string[]) {
        if (!postIds || !Array.isArray(postIds) || postIds.length === 0) {
            throw new Error("Invalid post IDs");
        }

        const posts = await postRepo.findPostsByIds(postIds);
        if (!posts || posts.length === 0) {
            throw new Error("No posts found for the provided IDs");
        }

        return posts;
    }

    async toggleLikePost({ postId, userId }: LikePostInput) {
        const post = await postRepo.findPostById(postId);
        if (!post) throw new Error("Post not found");

        const user = await userRepo.findUserById(userId);
        if (!user) throw new Error("User not found");

        const userObjectId = new mongoose.Types.ObjectId(userId);
        const alreadyLiked = post.likes.some((id) => id.equals(userObjectId));

        if (alreadyLiked) {
            post.likes = post.likes.filter((id) => id.toString() !== userId);
            user.likedPosts = user.likedPosts.filter((id) => id.toString() !== postId);
        } else {
            post.likes.push(userObjectId);
            user.likedPosts.push(post._id);
        }

        await postRepo.savePost(post);
        await userRepo.saveUser(user);

        return post;
    }

    async getPersonalizedFeed(userId: string, page: number, limit: number) {
        const skip = (page - 1) * limit;
        const redisKey = `feed:${userId}`;

        let posts: any[] = [];
        const cached = await this.redisClient.get(redisKey);

        if (cached) {
            posts = JSON.parse(cached);
        } else {
            posts = await this.feedService.getFeed(userId);
            await this.redisClient.setEx(redisKey, 300, JSON.stringify(posts)); // cache 5 phút
        }

        return posts.slice(skip, skip + limit);
    }

    async getPaginatedPosts(page: number, limit: number) {
        if (page < 1 || limit < 1) {
            throw new Error("Page and limit must be greater than 0");
        }
        const skip = (page - 1) * limit;
        const posts = await postRepo.findAllPosts(skip, limit);

        return {
            posts,
            hasMore: posts.length === limit,
        };
    }
}

```

### killigraphy_back_end\src\services\save.service.ts
```ts
// src/services/SaveService.ts
import { ISaveFactory } from "../factories/SaveFactory/ISaveFactory";
import { saveRepo } from "../repositories/save.repository";

export class SaveService {
    constructor(private saveFactory: ISaveFactory) { }

    async savePost(userId: string, postId: string) {
        const existing = await saveRepo.findSave(userId, postId);
        if (existing) throw new Error('Already saved');

        const saveData = this.saveFactory.create({ userId, postId });
        const savedPost = await saveRepo.createSave(saveData);
        if (!savedPost) throw new Error('Failed to save post');

        return savedPost;
    }

    async unsavePost(userId: string, postId: string) {
        const deleted = await saveRepo.deleteSave(userId, postId);
        if (!deleted) throw new Error('Save not found');
    }

    async getSavedPosts(userId: string) {
        return await saveRepo.getSavedPosts(userId);
    }
}

```

### killigraphy_back_end\src\services\user.service.ts
```ts
// services/userService.ts
import * as userRepo from '../repositories/user.repository';
import { UpdateUserProfileInput } from '../types';
import Users from '../models/Users';
import bcrypt from 'bcryptjs';
import Posts from '../models/Posts';
import { hashPassword } from '../utils/hashPassword';
import { IImageKitAdapter } from '../utils/adapters/ImageKitAdapter/IImageKitAdapter';
import { IRedisAdapter } from '../utils/adapters/RedisAdapter/IRedisAdapter';
import { IUpdateStrategy } from '../strategies/UpdateStrategy/IUpdateStrategy';

export class UserService {
    constructor(
        private updateStrategy: IUpdateStrategy<UpdateUserProfileInput, any>,
        private imageKitAdapter: IImageKitAdapter,
        private redisClient: IRedisAdapter
    ) { }

    async getPaginatedUsersWithFallback(userId: string, page = 1, limit = 10) {
        const skip = (page - 1) * limit;
        const zsetKey = `suggestions:zset:${userId}`;

        const totalRedisCount = await this.redisClient.zCard(zsetKey);
        const redisUsersRaw = await this.redisClient.zRevRange(zsetKey, skip, skip + limit - 1);
        const redisUserIds = redisUsersRaw.map(id => id.toString());
        const redisUsers = await userRepo.findUsersByIds(redisUserIds);
        const fetchedRedisCount = redisUsers.length;

        if (fetchedRedisCount >= limit) {
            return redisUsers;
        }

        const excludedIds = [...redisUserIds, userId];
        const fallbackSkip = Math.max(0, skip - totalRedisCount);
        const fallbackLimit = limit - fetchedRedisCount;

        const mongoUsers = await userRepo.findUsersNotIn(excludedIds, fallbackSkip, fallbackLimit);

        return [...redisUsers, ...mongoUsers];
    };

    async getUserById(userId: string) {
        const user = await userRepo.findUserById(userId);
        if (!user) {
            throw new Error('User not found');
        }
        return user;
    };

    async getFollowersWithFollowStatus(targetUserId: string, currentUserId: string) {
        const [targetUser, currentUser] = await Promise.all([
            userRepo.findUserByIdWithFollowers(targetUserId),
            userRepo.findUserById(currentUserId),
        ]);

        if (!targetUser) throw new Error('Target user not found');
        if (!currentUser) throw new Error('Current user not found');

        const followersWithFollowStatus = (targetUser.followers as any[]).map((follower) => ({
            _id: follower._id,
            name: follower.name,
            username: follower.username,
            imageUrl: follower.imageUrl,
            isFollowing: currentUser.following?.some(
                (id) => id.toString() === follower._id.toString()
            ) ?? false,
        }));

        return followersWithFollowStatus;
    };

    async getFollowing(userId: string) {
        const user = await userRepo.findUserByIdWithFollowing(userId);
        if (!user) throw new Error('User not found');
        return user.following;
    };

    async checkIsFollowing(currentUserId: string, targetUserId: string) {
        const currentUser = await userRepo.findUserById(currentUserId);
        if (!currentUser) throw new Error('User not found');

        const isFollowing = currentUser.following.some(id => id.equals(targetUserId));
        return isFollowing;
    };

    async toggleFollowUser(currentUserId: string, targetUserId: string) {
        if (currentUserId === targetUserId) {
            throw new Error('You cannot follow yourself');
        }

        const [targetUser, currentUser] = await Promise.all([
            userRepo.findUserById(targetUserId),
            userRepo.findUserById(currentUserId),
        ]);

        if (!targetUser || !currentUser) {
            throw new Error('User not found');
        }

        const isFollowing = currentUser.following.some(id => id.equals(targetUser._id));

        if (isFollowing) {
            // Unfollow
            currentUser.following = currentUser.following.filter(id => !id.equals(targetUser._id));
            targetUser.followers = targetUser.followers.filter(id => !id.equals(currentUser._id));
        } else {
            // Follow
            currentUser.following.push(targetUser._id);
            targetUser.followers.push(currentUser._id);
        }

        await Promise.all([
            userRepo.saveUser(currentUser),
            userRepo.saveUser(targetUser)
        ]);

        return {
            message: isFollowing ? "Unfollowed successfully" : "Followed successfully",
            isFollowing: !isFollowing,
        };
    };

    async updateUserProfile(data: UpdateUserProfileInput) {
        return await this.updateStrategy.update(data);
    }

    async updateUserPassword(userId: string, oldPassword: string, newPassword: string) {
        const user = await userRepo.findUserByIdWithPassword(userId);
        if (!user) throw new Error('User not found');

        const isMatch = await bcrypt.compare(oldPassword, user.password);
        if (!isMatch) throw new Error('Old password is incorrect');

        user.password = await hashPassword(newPassword);
        await userRepo.saveUser(user);

        return { message: 'Password updated successfully' };
    };

    async getUserSuggestions(userId: string, page: number, limit: number) {
        const skip = (page - 1) * limit;
        const cacheKey = `suggestions:${userId}:page:${page}`;
        const zsetKey = `suggestions:zset:${userId}`;

        // Check cached page
        const cached = await this.redisClient.get(cacheKey);
        if (cached) {
            return JSON.parse(cached);
        }

        const totalSuggestions = await this.redisClient.zCard(zsetKey);
        if (totalSuggestions === 0) {
            const currentUser = await userRepo.findUserById(userId).select('following');
            if (!currentUser) throw new Error('User not found');

            const excludedIds = [userId, ...currentUser.following.map((id: any) => id.toString())];
            const mutualMap = new Map<string, number>();

            const followedUsers = await userRepo.findUserById(userId).select('following');
            const followeds = await Users.find({ _id: { $in: currentUser.following } }).select('following');

            for (const u of followeds) {
                for (const followee of u.following) {
                    const strId = followee.toString();
                    if (!excludedIds.includes(strId)) {
                        mutualMap.set(strId, (mutualMap.get(strId) || 0) + 1);
                    }
                }
            }

            const userPosts = await Posts.find({ $or: [{ author: userId }, { likes: userId }] }).select('tags');
            const tagCount: Record<string, number> = {};
            userPosts.forEach(p => {
                if (p.tags) {
                    p.tags.forEach(tag => {
                        tagCount[tag] = (tagCount[tag] || 0) + 1;
                    });
                }
            });

            const allOtherUsers = await Users.find({ _id: { $nin: excludedIds } }).select('_id');
            const userIdList = allOtherUsers.map(u => u._id.toString());

            for (const otherUserId of userIdList) {
                const posts = await Posts.find({ author: otherUserId }).select('tags');
                let tagScore = 0;
                posts.forEach(post => {
                    if (post.tags) {
                        post.tags.forEach(tag => {
                            tagScore += tagCount[tag] || 0;
                        });
                    }
                });

                const mutualScore = mutualMap.get(otherUserId) || 0;
                const finalScore = mutualScore * 10 + tagScore;

                if (finalScore > 0) {
                    await this.redisClient.zAdd(zsetKey, finalScore, otherUserId);
                }
            }

            await this.redisClient.expire(zsetKey, 300); // cache ZSET 5 minutes
        }

        const suggestedIds = await this.redisClient.zRevRange(zsetKey, skip, skip + limit - 1);
        const suggestedUsers = await Users.find({ _id: { $in: suggestedIds } }).select('-password -__v -createdAt -updatedAt');

        await this.redisClient.setEx(cacheKey, 300, JSON.stringify(suggestedUsers));

        return suggestedUsers;
    };
}

```

### killigraphy_back_end\src\strategies\FeedStrategy\FeedContext.ts
```ts
import { IFeedStrategy } from './IFeedStrategy';

export class FeedContext {
    constructor(private strategy: IFeedStrategy) { }

    setStrategy(strategy: IFeedStrategy) {
        this.strategy = strategy;
    }

    async getFeed(userId: string) {
        return await this.strategy.generateFeed(userId);
    }
}

```

### killigraphy_back_end\src\strategies\FeedStrategy\IFeedStrategy.ts
```ts
export interface IFeedStrategy {
    generateFeed(userId: string): Promise<any[]>;
}

```

### killigraphy_back_end\src\strategies\FeedStrategy\PersonalizedFeedStrategy.ts
```ts
import { IFeedStrategy } from './IFeedStrategy';
import Post from '../../models/Posts';
import User from '../../models/Users';
import Comment from '../../models/Comment';

const MIN_FEED_POSTS = 30;

export class PersonalizedFeedStrategy implements IFeedStrategy {
    async generateFeed(userId: string): Promise<any[]> {
        const user = await User.findById(userId)
            .select('following likedPosts')
            .populate({ path: 'likedPosts', select: 'tags' });

        if (!user) throw new Error('User not found');

        const likedTags = new Set<string>();
        user.likedPosts?.forEach((post: any) => {
            post.tags?.forEach((tag: string) => likedTags.add(tag));
        });

        const commentTags = await Comment.aggregate([
            { $match: { user: user._id } },
            {
                $lookup: {
                    from: 'posts',
                    localField: 'post',
                    foreignField: '_id',
                    as: 'postInfo',
                },
            },
            { $unwind: '$postInfo' },
            { $project: { tags: '$postInfo.tags' } },
        ]);
        commentTags.forEach((c) => {
            c.tags?.forEach((tag: string) => likedTags.add(tag));
        });

        const followingIds = user.following?.map((id) => id.toString()) ?? [];

        const [fromFollowing, relatedPosts] = await Promise.all([
            Post.find({ creator: { $in: followingIds } })
                .sort({ createdAt: -1 })
                .limit(50)
                .populate('creator', 'name username imageUrl'),

            Post.find({
                tags: { $in: Array.from(likedTags) },
                creator: { $nin: [...followingIds, userId] },
            })
                .sort({ createdAt: -1 })
                .limit(50)
                .populate('creator', 'name username imageUrl'),
        ]);

        const mergedMap = new Map<string, any>();
        [...fromFollowing, ...relatedPosts].forEach((post) => {
            mergedMap.set(post._id.toString(), post);
        });

        if (mergedMap.size < MIN_FEED_POSTS) {
            const existingIds = Array.from(mergedMap.keys());
            const fallbackPosts = await Post.find({ _id: { $nin: existingIds } })
                .sort({ createdAt: -1 })
                .limit(MIN_FEED_POSTS)
                .populate('creator', 'name username imageUrl');

            fallbackPosts.forEach((post) => {
                mergedMap.set(post._id.toString(), post);
            });
        }

        const posts = Array.from(mergedMap.values()).map((post: any) => {
            const likeCount = post.likes?.length || 0;
            const hoursPassed = (Date.now() - new Date(post.createdAt).getTime()) / 3600000;
            const relevanceScore = likeCount * 2 - hoursPassed * 0.5;

            return {
                ...post.toObject(),
                relevanceScore,
            };
        });

        posts.sort((a, b) => b.relevanceScore - a.relevanceScore);

        return posts;
    }
}

```

### killigraphy_back_end\src\strategies\UpdateStrategy\IUpdateStrategy.ts
```ts
export interface IUpdateStrategy<TInput, TResult> {
    update(data: TInput): Promise<TResult>;
}
```

### killigraphy_back_end\src\strategies\UpdateStrategy\PostUpdateStrategy.ts
```ts
// src/strategies/UpdateStrategy/PostUpdateStrategy.ts
import { IUpdateStrategy } from './IUpdateStrategy';
import { UpdatePostInput } from '../../types';
import * as postRepo from '../../repositories/post.repository';
import { IImageKitAdapter } from '../../utils/adapters/ImageKitAdapter/IImageKitAdapter';

export class PostUpdateStrategy implements IUpdateStrategy<UpdatePostInput, any> {
    constructor(private imageKitAdapter: IImageKitAdapter) { }

    async update({ id, caption, location, tags, image }: UpdatePostInput) {
        const post = await postRepo.findPostById(id);
        if (!post) throw new Error("Post not found");

        // Console log for debugging image upload
        if (image && image.buffer) {
            console.log("Image buffer exists:", Buffer.isBuffer(image.buffer));
        } else {
            console.log("No image buffer provided or invalid format.");
        }

        if (image && image.buffer && Buffer.isBuffer(image.buffer)) {
            if (post.imageId) {
                try {
                    await this.imageKitAdapter.delete(post.imageId);
                } catch (err) {
                    console.error("Failed to delete old image:", err);
                }
            }

            const result = await this.imageKitAdapter.upload(image);

            post.imageId = result.fileId;
            post.imageURL = result.url;
        }

        post.caption = caption ?? post.caption;
        post.location = location ?? post.location;
        post.tags = tags ? tags.split(",").map(tag => tag.trim()) : post.tags;

        return await postRepo.savePost(post);
    }
}

```

### killigraphy_back_end\src\strategies\UpdateStrategy\UserUpdateStrategy.ts
```ts
// src/strategies/UpdateStrategy/UserUpdateStrategy.ts
import { IUpdateStrategy } from './IUpdateStrategy';
import { UpdateUserProfileInput } from '../../types';
import * as userRepo from '../../repositories/user.repository';
import { IImageKitAdapter } from '../../utils/adapters/ImageKitAdapter/IImageKitAdapter';

export class UserUpdateStrategy implements IUpdateStrategy<UpdateUserProfileInput, any> {
    constructor(private imageKitAdapter: IImageKitAdapter) { }

    async update({ userId, username, name, bio, file }: UpdateUserProfileInput) {
        const user = await userRepo.findUserById(userId);
        if (!user) throw new Error('User not found');

        if (name) user.name = name;
        if (username) user.username = username;
        if (bio) user.bio = bio;

        if (file?.buffer && Buffer.isBuffer(file.buffer)) {
            if (user.imageId) {
                try {
                    await this.imageKitAdapter.delete(user.imageId);
                } catch (err) {
                    console.warn('Delete old image failed:', err);
                }
            }

            const uploaded = await this.imageKitAdapter.upload(file);
            user.imageId = uploaded.fileId;
            user.imageUrl = uploaded.url;
        }

        await userRepo.saveUser(user);

        return user;
    }
}

```

### killigraphy_back_end\src\types\index.ts
```ts
import { Request, Response } from "express";
import mongoose from "mongoose";

interface AuthenticatedRequest extends Request {
    userId?: string;
}

interface RegisterUserInput {
    name: string;
    username: string;
    email: string;
    password: string;
}

interface LoginUserInput {
    email: string;
    password: string;
}

interface UserDocument extends mongoose.Document {
    name: string;
    username: string;
    accountId: string;
    email: string;
    password: string;
    bio?: string;
    imageId?: string;
    imageUrl: string;
    likedPosts: mongoose.Types.ObjectId[];
    followers: mongoose.Types.ObjectId[];
    following: mongoose.Types.ObjectId[];
    createdAt: Date;
    updatedAt: Date;
}

interface UpdateUserProfileInput {
    userId: string;
    username?: string;
    name?: string;
    bio?: string;
    file?: Express.Multer.File;
}

interface PostDocument extends mongoose.Document {
    creator: mongoose.Types.ObjectId;
    caption?: string;
    tags?: string[];
    imageURL: string;
    imageId: string;
    location?: string;
    likes: mongoose.Types.ObjectId[];
    createdAt: Date;
    updatedAt: Date;
}

interface CreatePostInput {
    caption: string;
    location?: string;
    tags?: string;
    file: Express.Multer.File;
    userId: string;
}

interface CreatePostResponse {
    creator: string;
    caption: string;
    location?: string;
    tags?: string[];
    imageId: string;
    imageURL: string;
}

interface UpdatePostInput {
    id: string;
    caption?: string;
    location?: string;
    tags?: string;
    image?: Express.Multer.File;
    userId: string;
}

interface LikePostInput {
    postId: string;
    userId: string;
}

interface CommentDocument extends Document {
    content: string;
    post: mongoose.Types.ObjectId;
    user: mongoose.Types.ObjectId;
    parent?: mongoose.Types.ObjectId | null;
    createdAt: Date;
    updatedAt: Date;
}

interface CreateCommentInput {
    content: string;
    postId: string;
    userId: string;
    parentId?: string;
}

interface SaveDocument extends Document {
    user: mongoose.Types.ObjectId;
    post: mongoose.Types.ObjectId;
    createdAt: Date;
    updatedAt: Date;
}

interface CreateSaveInput {
    userId: string;
    postId: string;
}

export type {
    AuthenticatedRequest,
    RegisterUserInput,
    LoginUserInput,
    UserDocument,
    UpdateUserProfileInput,
    PostDocument,
    CreatePostInput,
    CreatePostResponse,
    UpdatePostInput,
    LikePostInput,
    CommentDocument,
    CreateCommentInput,
    SaveDocument,
    CreateSaveInput,
};
```

### killigraphy_back_end\src\utils\default-user.py
```py
import random
import uuid
from datetime import datetime, timedelta
import json

def fake_object_id():
    return ''.join(random.choices('abcdef0123456789', k=24))

names = ["Alex", "Jamie", "Chris", "Taylor", "Jordan", "Morgan", "Casey", "Skyler", "Riley", "Jesse"]
usernames = ["alex123", "jamie_dev", "chris_runner", "taylor.music", "jordy321", "morgan.tech", "caseyx", "skyler.code", "riley_ui", "jesse.data"]

user_ids = [fake_object_id() for _ in range(100)]
users = []

for i in range(100):
    created = datetime.utcnow() - timedelta(days=random.randint(10, 365))
    updated = created + timedelta(days=random.randint(0, 30))

    user_id = user_ids[i]
    name = random.choice(names)
    username = f"{usernames[i % len(usernames)]}_{i}"

    following_ids = random.sample([uid for uid in user_ids if uid != user_id], k=random.randint(2, 5))

    user = {
        "name": name,
        "username": username,
        "accountId": str(uuid.uuid4()),
        "email": f"{username}@example.com",
        "password": "$2a$10$qygOGXGVHSUBPnOa35mneePZwRuZvpxEM67NyvQcX4/087.nE.28O",
        "imageUrl": f"https://ik.imagekit.io/killigraphy/avatars/avatar_{i}.jpg",
        "likedPosts": [],
        "followers": [],
        "following": [{ "$oid": fid } for fid in following_ids],
        "createdAt": { "$date": created.isoformat() + "Z" },
        "updatedAt": { "$date": updated.isoformat() + "Z" },
        "__v": 0,
        "imageId": fake_object_id()
    }

    users.append(user)

id_to_user = {user_ids[i]: users[i] for i in range(100)}
for i in range(100):
    user = users[i]
    user_id = user_ids[i]
    for following in user["following"]:
        fid = following["$oid"]
        if {"$oid": user_id} not in id_to_user[fid]["followers"]:
            id_to_user[fid]["followers"].append({"$oid": user_id})

with open("default_users.json", "w", encoding="utf-8") as f:
    json.dump(users, f, indent=4, ensure_ascii=False)

print("✅ Created default_users.json with 100 users")

```

### killigraphy_back_end\src\utils\default_posts.py
```py
from pymongo import MongoClient
from bson import ObjectId
import random
import json
from datetime import datetime, timedelta

# Kết nối MongoDB
client = MongoClient("mongodb://localhost:27017")
db = client["killigraphy"]
users_collection = db["users"]

# Lấy danh sách user từ MongoDB
users_cursor = users_collection.find({}, {"_id": 1, "followers": 1})
users = list(users_cursor)

if not users:
    raise ValueError("❌ Không có user nào trong MongoDB")

user_ids = [str(u["_id"]) for u in users]

caption_templates = [
    "Just finished a {} session at {}!",
    "Loving the vibe here in {} 🌇",
    "Trying out some new {} techniques 🎨",
    "Spent the day working on {} ☕",
    "Here's what {} looks like from above 🚁",
    "Guess where I took this? Hint: {} 🌍",
    "Late-night thoughts about {}.",
    "Anyone else obsessed with {} lately?",
    "If you love {}, you’ll love this!"
]

topics = ["yoga", "JavaScript", "sketching", "React", "UX design", "street photography", "coffee", "travel", "AI"]
places = ["Bali", "New York", "Hanoi", "Tokyo", "Berlin", "Da Nang", "London", "Seoul"]
tags_by_topic = {
    "yoga": ["fitness", "health", "balance"],
    "JavaScript": ["code", "devlife", "frontend"],
    "sketching": ["art", "drawing", "creativity"],
    "React": ["reactjs", "webdev", "hooks"],
    "UX design": ["design", "uiux", "user"],
    "street photography": ["photo", "streetlife", "city"],
    "coffee": ["coffee", "cafevibes", "latteart"],
    "travel": ["wanderlust", "explore", "journey"],
    "AI": ["ai", "machinelearning", "futuretech"]
}

image_urls = [f"https://picsum.photos/seed/{ObjectId()}/800/600" for _ in range(30)]
posts = []

for _ in range(150):
    creator = random.choice(users)
    creator_id = str(creator["_id"])
    topic = random.choice(topics)
    place = random.choice(places)
    caption = random.choice(caption_templates).format(topic, place)

    tags = random.sample(tags_by_topic[topic], 2)
    created = datetime.utcnow() - timedelta(days=random.randint(1, 60))
    updated = created + timedelta(days=random.randint(0, 3))

    followers = creator.get("followers", [])
    follower_ids = [str(f) for f in followers]
    like_ids = random.sample(follower_ids, min(3, len(follower_ids)))
    like_ids += random.sample([uid for uid in user_ids if uid != creator_id], k=2)

    post = {
        "_id": { "$oid": str(ObjectId()) },
        "creator": { "$oid": creator_id },
        "caption": caption,
        "tags": tags,
        "imageURL": random.choice(image_urls),
        "imageId": str(ObjectId()),
        "location": random.choice(places),
        "likes": [{ "$oid": uid } for uid in set(like_ids)],
        "createdAt": { "$date": created.isoformat() + "Z" },
        "updatedAt": { "$date": updated.isoformat() + "Z" },
        "__v": 0
    }

    posts.append(post)

# Xuất ra file JSON
with open("default_posts.json", "w", encoding="utf-8") as f:
    json.dump(posts, f, indent=4, ensure_ascii=False)

print("✅ Created default_posts.json with", len(posts), "posts")

```

### killigraphy_back_end\src\utils\hashPassword.ts
```ts
// utils/hashPassword.ts
import bcrypt from 'bcryptjs';

export const hashPassword = async (password: string) => {
    return await bcrypt.hash(password, 10);
};

```

### killigraphy_back_end\src\utils\sendEmail.ts
```ts
import nodemailer from 'nodemailer';

export const sendEmail = async (to: string, subject: string, text: string) => {

    const transporter = nodemailer.createTransport({
        service: 'gmail',
        auth: {
            user: process.env.GMAIL_USER,
            pass: process.env.GMAIL_PASS,
        },
    });

    const mailOptions = {
        from: `Killigraphy <${process.env.GMAIL_USER}>`,
        to,
        subject,
        text,
    };

    try {
        const info = await transporter.sendMail(mailOptions);
        console.log('Email sent:', info.response);
    } catch (err) {
        console.error('Failed to send email:', err);
        throw err;
    }
};

```

### killigraphy_back_end\src\utils\adapters\ImageKitAdapter\IImageKitAdapter.ts
```ts
export interface IImageKitAdapter {
    upload(file: Express.Multer.File): Promise<{ url: string; fileId: string }>;
    delete(fileId: string): Promise<void>;
}

```

### killigraphy_back_end\src\utils\adapters\ImageKitAdapter\ImageKitAdapter.ts
```ts
import imagekit from "../../../config/imagekit";
import { IImageKitAdapter } from "./IImageKitAdapter";

export class ImageKitAdapter implements IImageKitAdapter {
    async upload(file: Express.Multer.File) {
        if (!file.buffer) {
            throw new Error("Missing file buffer");
        }

        const uploaded = await imagekit.upload({
            file: file.buffer,
            fileName: file.originalname,
            folder: "/posts/images",
        });

        return {
            url: uploaded.url,
            fileId: uploaded.fileId,
        };
    }

    async delete(fileId: string) {
        if (!fileId) {
            throw new Error("Missing file ID");
        }
        await imagekit.deleteFile(fileId);
    }
}

```

### killigraphy_back_end\src\utils\adapters\RedisAdapter\IRedisAdapter.ts
```ts
export interface IRedisAdapter {
    get(key: string): Promise<string | null>;
    set(key: string, value: string): Promise<'OK'>;
    setEx(key: string, seconds: number, value: string): Promise<'OK'>;
    del(key: string): Promise<number>;

    zAdd(key: string, score: number, member: string): Promise<number>;
    zCard(key: string): Promise<number>;
    zRevRange(key: string, start: number, stop: number): Promise<string[]>;

    expire(key: string, seconds: number): Promise<number>;
}

```

### killigraphy_back_end\src\utils\adapters\RedisAdapter\RedisAdapter.ts
```ts

import RedisClient from '../../../config/redis';
import { IRedisAdapter } from './IRedisAdapter';

export class RedisAdapter implements IRedisAdapter {
    private client = RedisClient.getInstance();

    async get(key: string): Promise<string | null> {
        return await this.client.get(key);
    }

    async set(key: string, value: string): Promise<'OK'> {
        return await this.client.set(key, value);
    }

    async setEx(key: string, seconds: number, value: string): Promise<'OK'> {
        return await this.client.setex(key, seconds, value);
    }

    async del(key: string): Promise<number> {
        return await this.client.del(key);
    }

    async zAdd(key: string, score: number, member: string): Promise<number> {
        return await this.client.zadd(key, score, member);
    }

    async zCard(key: string): Promise<number> {
        return await this.client.zcard(key);
    }

    async zRevRange(key: string, start: number, stop: number): Promise<string[]> {
        return await this.client.zrevrange(key, start, stop);
    }

    async expire(key: string, seconds: number): Promise<number> {
        return await this.client.expire(key, seconds);
    }
}

```

### killigraphy_back_end\src\utils\singleton\ImageKitAdapterSingleton.ts
```ts
import { ImageKitAdapter } from "../adapters/ImageKitAdapter/ImageKitAdapter";

export const imageKitAdapterSingleton = new ImageKitAdapter();

```

### killigraphy_back_end\src\utils\singleton\RedisAdapterSingleton.ts
```ts
import { RedisAdapter } from "../adapters/RedisAdapter/RedisAdapter";

export const redisAdapterSingleton = new RedisAdapter();

```
